---

---

## **Integer Addition**

Example 7 + 6
![](../images/Pasted%20image%2020250401154607.png)

결과 값이 표현 범위를 넘어서면 **오버플로우(overflow)** 가 발생한다.  
`+ve`(양수)와 `-ve`(음수)를 더하는 연산에서는 오버플로우가 발생하지 않는다.

하지만 두 개의 `+ve`(양수)를 더했을 때 오버플로우가 발생하면, **결과의 부호 비트가 1**로 바뀌어 음수처럼 보이게 된다.  
반대로 두 개의 `-ve`(음수)를 더했을 때 오버플로우가 발생하면, **결과의 부호 비트가 0**이 되어 양수처럼 보인다.


---
## **Integer Subtraction**

Example 7 - 6 = 7 + (-6)
![](../images/Pasted%20image%2020250401235049.png)

|연산 유형|오버플로우 발생 여부|오버플로우 발생 조건|
|---|---|---|
|+ve - +ve 또는 -ve - -ve|❌ 없음|없음|
|-ve - +ve|✅ 가능성 있음|결과의 부호가 **0(양수)**일 때|
|+ve - -ve|✅ 가능성 있음|결과의 부호가 **1(음수)**일 때|


---
## **Dealing with Overflow**

C와 같은 일부 언어는 **오버플로우를 무시**한다.  
MIPS에서도 `addu`, `addiu`, `subu` 같은 명령어는 **오버플로우를 검사하지 않는다.**

반면, **Ada**나 **Fortran**과 같은 언어는 오버플로우가 발생하면 **예외를 발생시킨다.**  
MIPS에서는 `add`, `addi`, `sub` 명령어가 이에 해당하며,  오버플로우 발생 시 **예외 핸들러가 호출된다.**

이때, 현재 명령어의 주소는 **EPC(Exception Program Counter)** 레지스터에 저장되며,  
제어 흐름은 사전에 정의된 **예외 핸들러 주소**로 이동한다.  
예외 처리 후에는 `mfc0`(move from coprocessor 0) 명령어를 사용해  
EPC 값을 복원하고, 적절한 조치를 취한 뒤 **원래 실행하던 위치로 복귀**할 수 있다.

---
## **Arithmetic for Multimedia**

그래픽 처리나 8비트 벡터, 16비트 데이터 등에서 동작하도록 설계된 **멀티미디어 연산기**는  
**64비트 덧셈기(adder)** 를 사용하되, **분할된 캐리 체인(partitioned carry chain)** 방식으로 구성된다.

즉, 하나의 큰 연산기를 다음과 같이 **작은 단위로 나누어 병렬 연산**이 가능하도록 만든다:

- 8 × 8비트
- 4 × 16비트
- 2 × 32비트

이처럼 한 번에 여러 데이터를 동시에 처리하는 방식은  **SIMD (Single Instruction, Multiple Data)** 구조의 대표적인 예시다.

###  Saturating Operations (포화 연산)

- 오버플로우가 발생했을 때, 결과를 **표현 가능한 최대값으로 고정**  
    → 더 이상 넘치지 않고 **“포화(saturation)”** 상태로 유지됨
- 이는 일반적인 오버플로우 시 부호가 반전되는 **2의 보수(modulo arithmetic)** 방식과는 다르다.

- **오디오 클리핑(audio clipping)**
- **비디오 색상 포화(video saturation)**

---
## **Multiplication**

![](../images/Pasted%20image%2020250402000032.png)

![](../images/Pasted%20image%2020250402000109.png)

![](../images/Pasted%20image%2020250402000219.png)

- **multiplier의 마지막 비트(LSB)** 가 `1`이면:
    - **처음이든 아니든** `multiplicand`를 `product`에 더함
        
- **multiplier의 마지막 비트**가 `0`이면:
    - **덧셈 없이** 시프트만 수행
        
- 매 단계마다:
    - `multiplicand`는 **왼쪽으로 시프트 (×2)**
    - `multiplier`는 **오른쪽으로 시프트 (÷2)**

---
## **Optimized Multiplier**

![](../images/Pasted%20image%2020250402094051.png)

곱셈 연산에서는 **덧셈(add)** 과 **시프트(shift)** 가 **병렬적으로 수행**된다.  
즉, **각 partial product(부분 곱)** 을 더할 때마다  
**한 사이클(cycle)** 이 소요되며,  
이 과정은 **매 단계마다 반복**된다.

이러한 방식은 **곱셈 연산의 빈도가 낮을 경우**에는  
성능 측면에서 **충분히 괜찮은 방식**으로 간주된다.

![](../images/Pasted%20image%2020250402094331.png)

- 처음부터 **Product 레지스터의 하위 비트**에 **Multiplier 값**이 포함됨
- 각 사이클마다 **Product의 마지막 비트(LSB)** 를 검사

#### 👉 만약 LSB가 `1`이라면:

- **Multiplicand를 Product의 상위 비트 영역에 더함**
- 그리고 Product 전체를 **오른쪽으로 시프트**
    

#### 👉 만약 LSB가 `0`이라면:

- **덧셈 없이** 그냥 **Product를 오른쪽으로 시프트**함
- 이때 오른쪽 시프트를 통해 Product의 마지막 비트는 **버려지게 됨**

---
## **Faster Multiplier**

- **여러 개의 가산기(adders)** 를 사용해  **부분 곱(partial products)** 을 동시에 더함
- **병렬 처리**를 통해 속도를 높이는 구조

- **Pipelining** 가능  → 각 연산 단계를 파이프라인으로 분리하면  여러 곱셈을 **동시에 처리** 가능
- **Cost / Performance tradeoff**  → 빠르지만 **하드웨어 자원(면적, 소비 전력 등)** 이 더 듦

![](../images/Pasted%20image%2020250402094856.png)

---
## **MIPS Multiplication**

MIPS는 곱셈 결과를 저장하기 위해 **두 개의 32비트 전용 레지스터**를 사용한다:

- `HI`: 상위 32비트 (Most-Significant Bits)
- `LO`: 하위 32비트 (Least-Significant Bits)
#### 명령어

```
mult rs, rt              // 부호 있는 곱셈
multu rs, rt             // 부호 없는 곱셈
```

결과는 64비트이며,  **상위 32비트 → HI**, **하위 32비트 → LO**에 저장됨


```
mfhi rd  → HI 레지스터 값을 `rd`로 복사 move from HI
mflo rd  → LO 레지스터 값을 `rd`로 복사 move from LO
```
    
예: 32비트 이하 결과만 필요한 경우에는 `mflo`만 사용
**HI 값이 0이 아니면**, 결과가 32비트를 초과했음을 의미 (오버플로우 판단 가능)

```assembly
mul rd, rs, rt → rs * rt해서 rd에 넣기
```

곱했을 때 32비트의 결과를 바로 rd 에 넣을 수 있다.

---

## **Division**

**나누는 수(divisor)** 와 **나눠지는 수(dividend)** 를 비교하고,  뺄 수 있을 만큼 **왼쪽으로 시프트(shift)** 하면서 **뺄 수 있으면 빼고**, 그렇지 않으면 넘어가며  **몫과 나머지를 계산**하는 방식

- **우선 빼본다** (dividend에서 divisor를 뺌)
    
- **결과가 0 이상이면**  빼는 것이 성공한 것이므로, **몫 비트에 1 저장**
    
- **결과가 0보다 작으면**  빼는 게 실패한 것이므로,  **다시 더해서 복구하고**, **몫 비트에 0 저장**
    
- 그 다음에는 **시프트 연산(왼쪽으로)** 을 수행하여  다음 비트를 처리할 준비를 한다

음수일 경우에 
