---

---

## **Integer Addition**

Example 7 + 6
![](../images/Pasted%20image%2020250401154607.png)

결과 값이 표현 범위를 넘어서면 **오버플로우(overflow)** 가 발생한다.  
`+ve`(양수)와 `-ve`(음수)를 더하는 연산에서는 오버플로우가 발생하지 않는다.

하지만 두 개의 `+ve`(양수)를 더했을 때 오버플로우가 발생하면, **결과의 부호 비트가 1**로 바뀌어 음수처럼 보이게 된다.  
반대로 두 개의 `-ve`(음수)를 더했을 때 오버플로우가 발생하면, **결과의 부호 비트가 0**이 되어 양수처럼 보인다.


---
## **Integer Subtraction**

Example 7 - 6 = 7 + (-6)
![](../images/Pasted%20image%2020250401235049.png)

|연산 유형|오버플로우 발생 여부|오버플로우 발생 조건|
|---|---|---|
|+ve - +ve 또는 -ve - -ve|❌ 없음|없음|
|-ve - +ve|✅ 가능성 있음|결과의 부호가 **0(양수)**일 때|
|+ve - -ve|✅ 가능성 있음|결과의 부호가 **1(음수)**일 때|


---
## **Dealing with Overflow**

C와 같은 일부 언어는 **오버플로우를 무시**한다.  
MIPS에서도 `addu`, `addiu`, `subu` 같은 명령어는 **오버플로우를 검사하지 않는다.**

반면, **Ada**나 **Fortran**과 같은 언어는 오버플로우가 발생하면 **예외를 발생시킨다.**  
MIPS에서는 `add`, `addi`, `sub` 명령어가 이에 해당하며,  오버플로우 발생 시 **예외 핸들러가 호출된다.**

이때, 현재 명령어의 주소는 **EPC(Exception Program Counter)** 레지스터에 저장되며,  
제어 흐름은 사전에 정의된 **예외 핸들러 주소**로 이동한다.  
예외 처리 후에는 `mfc0`(move from coprocessor 0) 명령어를 사용해  
EPC 값을 복원하고, 적절한 조치를 취한 뒤 **원래 실행하던 위치로 복귀**할 수 있다.

---
## **Arithmetic for Multimedia**

그래픽 처리나 8비트 벡터, 16비트 데이터 등에서 동작하도록 설계된 **멀티미디어 연산기**는  
**64비트 덧셈기(adder)** 를 사용하되, **분할된 캐리 체인(partitioned carry chain)** 방식으로 구성된다.

즉, 하나의 큰 연산기를 다음과 같이 **작은 단위로 나누어 병렬 연산**이 가능하도록 만든다:

- 8 × 8비트
- 4 × 16비트
- 2 × 32비트

이처럼 한 번에 여러 데이터를 동시에 처리하는 방식은  **SIMD (Single Instruction, Multiple Data)** 구조의 대표적인 예시다.

###  Saturating Operations (포화 연산)

- 오버플로우가 발생했을 때, 결과를 **표현 가능한 최대값으로 고정**  
    → 더 이상 넘치지 않고 **“포화(saturation)”** 상태로 유지됨
- 이는 일반적인 오버플로우 시 부호가 반전되는 **2의 보수(modulo arithmetic)** 방식과는 다르다.

- **오디오 클리핑(audio clipping)**
- **비디오 색상 포화(video saturation)**

---
## **Multiplication**

![](../images/Pasted%20image%2020250402000032.png)

![](../images/Pasted%20image%2020250402000109.png)

![](../images/Pasted%20image%2020250402000219.png)

- **multiplier의 마지막 비트(LSB)** 가 `1`이면:
    - **처음이든 아니든** `multiplicand`를 `product`에 더함
        
- **multiplier의 마지막 비트**가 `0`이면:
    - **덧셈 없이** 시프트만 수행
        
- 매 단계마다:
    - `multiplicand`는 **왼쪽으로 시프트 (×2)**
    - `multiplier`는 **오른쪽으로 시프트 (÷2)**

---
## **Optimized Multiplier**

![](../images/Pasted%20image%2020250402094051.png)

add랑 shift랑 병렬적으로 수행된다.

one cycle per partial-product addition
that's ok if frequency of multiplocations is low

![](../images/Pasted%20image%2020250402094331.png)

product에 처음부터 multiplier 있어서 multiplier가 1이