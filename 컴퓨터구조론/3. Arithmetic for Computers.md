---

---

## **Integer Addition**

Example 7 + 6
![](../images/Pasted%20image%2020250401154607.png)

결과 값이 표현 범위를 넘어서면 **오버플로우(overflow)** 가 발생한다.  
`+ve`(양수)와 `-ve`(음수)를 더하는 연산에서는 오버플로우가 발생하지 않는다.

하지만 두 개의 `+ve`(양수)를 더했을 때 오버플로우가 발생하면, **결과의 부호 비트가 1**로 바뀌어 음수처럼 보이게 된다.  
반대로 두 개의 `-ve`(음수)를 더했을 때 오버플로우가 발생하면, **결과의 부호 비트가 0**이 되어 양수처럼 보인다.


---
## **Integer Subtraction**

Example 7 - 6 = 7 + (-6)
![](../images/Pasted%20image%2020250401235049.png)

|연산 유형|오버플로우 발생 여부|오버플로우 발생 조건|
|---|---|---|
|+ve - +ve 또는 -ve - -ve|❌ 없음|없음|
|-ve - +ve|✅ 가능성 있음|결과의 부호가 **0(양수)**일 때|
|+ve - -ve|✅ 가능성 있음|결과의 부호가 **1(음수)**일 때|


---
## **Dealing with Overflow**

C와 같은 일부 언어는 **오버플로우를 무시**한다.  
MIPS에서도 `addu`, `addiu`, `subu` 같은 명령어는 **오버플로우를 검사하지 않는다.**

반면, **Ada**나 **Fortran**과 같은 언어는 오버플로우가 발생하면 **예외를 발생시킨다.**  
MIPS에서는 `add`, `addi`, `sub` 명령어가 이에 해당하며,  오버플로우 발생 시 **예외 핸들러가 호출된다.**

이때, 현재 명령어의 주소는 **EPC(Exception Program Counter)** 레지스터에 저장되며,  
제어 흐름은 사전에 정의된 **예외 핸들러 주소**로 이동한다.  
예외 처리 후에는 `mfc0`(move from coprocessor 0) 명령어를 사용해  
EPC 값을 복원하고, 적절한 조치를 취한 뒤 **원래 실행하던 위치로 복귀**할 수 있다.

---
## **Arithmetic for Multimedia**

그래픽 처리나 8비트 벡터, 16비트 데이터 등에서 동작하도록 설계된 **멀티미디어 연산기**는  
**64비트 덧셈기(adder)** 를 사용하되, **분할된 캐리 체인(partitioned carry chain)** 방식으로 구성된다.

즉, 하나의 큰 연산기를 다음과 같이 **작은 단위로 나누어 병렬 연산**이 가능하도록 만든다:

- 8 × 8비트
- 4 × 16비트
- 2 × 32비트

이처럼 한 번에 여러 데이터를 동시에 처리하는 방식은  **SIMD (Single Instruction, Multiple Data)** 구조의 대표적인 예시다.

###  Saturating Operations (포화 연산)

- 오버플로우가 발생했을 때, 결과를 **표현 가능한 최대값으로 고정**  
    → 더 이상 넘치지 않고 **“포화(saturation)”** 상태로 유지됨
- 이는 일반적인 오버플로우 시 부호가 반전되는 **2의 보수(modulo arithmetic)** 방식과는 다르다.

- **오디오 클리핑(audio clipping)**
- **비디오 색상 포화(video saturation)**

---
## **Multiplication**

![](../images/Pasted%20image%2020250402000032.png)

![](../images/Pasted%20image%2020250402000109.png)

![](../images/Pasted%20image%2020250402000219.png)

- **multiplier의 마지막 비트(LSB)** 가 `1`이면:
    - **처음이든 아니든** `multiplicand`를 `product`에 더함
        
- **multiplier의 마지막 비트**가 `0`이면:
    - **덧셈 없이** 시프트만 수행
        
- 매 단계마다:
    - `multiplicand`는 **왼쪽으로 시프트 (×2)**
    - `multiplier`는 **오른쪽으로 시프트 (÷2)**

---
## **Optimized Multiplier**

![](../images/Pasted%20image%2020250402094051.png)

곱셈 연산에서는 **덧셈(add)** 과 **시프트(shift)** 가 **병렬적으로 수행**된다.  
즉, **각 partial product(부분 곱)** 을 더할 때마다  
**한 사이클(cycle)** 이 소요되며,  
이 과정은 **매 단계마다 반복**된다.

이러한 방식은 **곱셈 연산의 빈도가 낮을 경우**에는  
성능 측면에서 **충분히 괜찮은 방식**으로 간주된다.

![](../images/Pasted%20image%2020250402094331.png)

- 처음부터 **Product 레지스터의 하위 비트**에 **Multiplier 값**이 포함됨
- 각 사이클마다 **Product의 마지막 비트(LSB)** 를 검사

#### 👉 만약 LSB가 `1`이라면:

- **Multiplicand를 Product의 상위 비트 영역에 더함**
- 그리고 Product 전체를 **오른쪽으로 시프트**
    

#### 👉 만약 LSB가 `0`이라면:

- **덧셈 없이** 그냥 **Product를 오른쪽으로 시프트**함
- 이때 오른쪽 시프트를 통해 Product의 마지막 비트는 **버려지게 됨**

---
## **Faster Multiplier**

- **여러 개의 가산기(adders)** 를 사용해  **부분 곱(partial products)** 을 동시에 더함
- **병렬 처리**를 통해 속도를 높이는 구조

- **Pipelining** 가능  → 각 연산 단계를 파이프라인으로 분리하면  여러 곱셈을 **동시에 처리** 가능
- **Cost / Performance tradeoff**  → 빠르지만 **하드웨어 자원(면적, 소비 전력 등)** 이 더 듦

![](../images/Pasted%20image%2020250402094856.png)

---
## **MIPS Multiplication**

MIPS는 곱셈 결과를 저장하기 위해 **두 개의 32비트 전용 레지스터**를 사용한다:

- `HI`: 상위 32비트 (Most-Significant Bits)
- `LO`: 하위 32비트 (Least-Significant Bits)
#### 명령어

```
mult rs, rt              // 부호 있는 곱셈
multu rs, rt             // 부호 없는 곱셈
```

결과는 64비트이며,  **상위 32비트 → HI**, **하위 32비트 → LO**에 저장됨


```
mfhi rd  → HI 레지스터 값을 `rd`로 복사 move from HI
mflo rd  → LO 레지스터 값을 `rd`로 복사 move from LO
```
    
예: 32비트 이하 결과만 필요한 경우에는 `mflo`만 사용
**HI 값이 0이 아니면**, 결과가 32비트를 초과했음을 의미 (오버플로우 판단 가능)

```assembly
mul rd, rs, rt → rs * rt해서 rd에 넣기
```

곱했을 때 32비트의 결과를 바로 rd 에 넣을 수 있다.

---

## **Division**

**나누는 수(divisor)** 와 **나눠지는 수(dividend)** 를 비교하고,  뺄 수 있을 만큼 **왼쪽으로 시프트(shift)** 하면서 **뺄 수 있으면 빼고**, 그렇지 않으면 넘어가며  **몫과 나머지를 계산**하는 방식

- **우선 빼본다** (dividend에서 divisor를 뺌)
    
- **결과가 0 이상이면**  빼는 것이 성공한 것이므로, **몫 비트에 1 저장**
    
- **결과가 0보다 작으면**  빼는 게 실패한 것이므로,  **다시 더해서 복구하고**, **몫 비트에 0 저장**
    
- 그 다음에는 **시프트 연산(왼쪽으로)** 을 수행하여  다음 비트를 처리할 준비를 한다

#### Signed Division

1. **우선 양수로 바꾸고 계산한다**
    나눠지는 수(dividend), 나누는 수(divisor) 중  **음수가 있다면 부호를 무시하고 절댓값으로 나눗셈 수행**
        
2. **나눗셈 완료 후**, 최종적으로 **몫의 부호** 결정:
    
    - **두 수의 부호가 같으면 → 양수**
        
    - **두 수의 부호가 다르면 → 음수**
        
3. **나머지(remainder)** 는 일반적으로 **dividend와 같은 부호**를 가짐



![](../images/Pasted%20image%2020250403121721.png)

복원 나눗셈은 Divisor를 상위에, Dividend를 하위에 배치한 뒤, Remainder에서 Divisor를 빼고 결과가 음수면 복원하고 몫에 0, 양수면 그대로 두고 몫에 1을 저장한 후 Quotient는 왼쪽, Divisor는 오른쪽으로 시프트하며 이 과정을 32~33번 반복한다.

![](../images/Pasted%20image%2020250403122012.png)


**Remainder - Divisor 연산 후 최상위 비트(MSB)가 1이면 음수이므로 복원하고, 0이면 그대로 두고 몫 비트에 1을 설정한다. 이후 Divisor는 계속 오른쪽으로 시프트하며, Remainder는 결과가 0일 때 오른쪽으로 시프트한다.**

---
## **Optimized Divider

![](../images/Pasted%20image%2020250403122305.png)

`Remainder`는 단순한 나머지 저장소가 아니라, **몫과 나머지를 함께 저장하거나 제어하는 복합 구조**이기 때문에 **시프트 연산이 가능하도록 되어 있다.** 계속 수행하다보면 왼쪽에 나머지 오른쪽은 몫이 남는다.

---
## **Faster Division

**곱셈**은 단순히 partial product들을 더해가는 방식이기 때문에  여러 연산을 **병렬로 쉽게 구성**할 수 있음 하지만 **나눗셈**은 매 스텝마다 **뺄 수 있는지 판단(sign 비교)** 해야 하므로  **조건부 분기**가 많아서 병렬화가 어려움

곱하기랑 나누기랑 연산 속도가 다르다. 일반적으로 나눗셈이 더 느리다.


---
## **MIPS Division

####  **MIPS에서 나눗셈 결과 저장 방식**

- **`HI` 레지스터**: **나머지 (Remainder)** 저장
- **`LO` 레지스터**: **몫 (Quotient)** 저장

#### 관련명령어

- `div rs, rt`    // signed division
- `divu rs, rt`   // unsigned division
    

> → `rs ÷ rt` 연산 수행 후:  
> → 몫은 `LO`, 나머지는 `HI`에 저장됨

- `mflo rd`  → `LO` 값(몫)을 일반 레지스터로 가져옴
- `mfhi rd`  → `HI` 값(나머지)을 일반 레지스터로 가져옴

**오버플로우나 0으로 나누기**에 대한 **하드웨어 체크 없음**→ 즉, 직접 **소프트웨어에서 검사**해야 함

---
## **MIPS Arithmetic Instructions Summary

![](../images/Pasted%20image%2020250403123158.png)

---
## **Floating Point

#### 1. **Fixed Point (고정소수점)**

- **정수처럼 저장하지만**, **어디에 소수점이 있다고 가정**하는 방식
- 예: `16비트 정수부 + 16비트 소수부` 라고 정해두면, `점`은 중간에 있는 걸로 간주
    
- **장점**: 단순하고 빠름 (정수 연산처럼 처리 가능)
- **단점**: 표현 범위가 작고 유연성이 부족함

#### 2. **Floating Point (부동소수점)**

- 숫자를 **정규화된 형태로 표현**
    
    > **±1.xxxxxxx₂ × 2ʸʸʸʸ** (2진수 기준)
    
- `1.` 뒤에 나오는 부분이 **유효 숫자 (mantissa)** 로 실질적인 숫자 정보를 담고 있다.
- `2의 지수 (exponent)`를 통해 **폭넓은 범위의 값**을 표현할 수 있다.

---
## **Floating Point Standard

다양한 컴퓨터마다 실수 표현 방식이 **제각각**이던 시절,  과학 계산의 이식성(portability)** 문제가 심각했다. 그래서 이를 **통일하기 위해 제정된 표준**이 바로 **IEEE 754-1985**
    
> 지금은 거의 모든 하드웨어에서 **사실상 표준**으로 사용됨

- Single precision (32-bit)
- Double precision (64-bit)

어디까지 x 를 넣고 어디까지 y를 넣을지 정하긴 하며 됨

---
## **IEEE Floating-Point Format

![](../images/Pasted%20image%2020250403124212.png)

##### ✅ **Sign (부호 비트)**

- 최상위 비트는 부호 판단에 사용됨
    
- `0`이면 양수, `1`이면 음수

##### ✅ **Significand (유효 숫자, 가수)**

부동소수점 수는 항상 다음과 같은 **정규화된 형태**로 표현됨:

$$    1.0≤∣significand∣<2.0$$

→ 즉, **소수점 앞에 항상 1이 오도록 조정**한다. 

정규화된 수는 항상 `1.xxxxxx` 형태이기 때문에,  소수점 앞의 **1은 저장하지 않아도 된다.**


##### ✅ **Exponent (지수)**
    > **±1.xxxxxxx₂ × 2ʸʸʸʸ** (2진수 기준)
부동소수점 수에서 **Exponent**는 숫자의 **크기(범위)** 를 조절하는 데 사용된다.
쉽게 말하면, **소수점의 위치를 얼마나 좌우로 이동시킬지**를 결정하는 부분이다.

여기서 **Exponent**는 실제 지수가 아니라, **Bias가 더해진 값으로 저장됨.

**지수 필드가 부호 없는 값(Unsigned)** 이기 때문에,  양수/음수 지수 모두 표현하기 위해 **Bias(편향 값)** 를 사용한다.

실제로 single이면 128을 빼주고
double 이면 1023을 빼준다.

##### ✅ **Fraction (가수 비트)**

 `1.` 뒤의 **실제 유효 숫자 비트들**을 말하며 그냥 x의 값을 그대로 넣어주면 된다. 즉, 정규화된 수에서 소수점 이하 비트만 저장됨

fp32 ( 8 bit exponent)
최솟값 0 
최대값 2^8 -1= 254
최솟값에서 -127하면 -127
최대값에서 -127 하면 127
-> 모든 숫자가 정렬되어 나타나게 된다.

---
## **Single-Precision Range

#### ✅ Exponent 비트는 8비트 (총 256개)

하지만 **`00000000` (0)** 과 **`11111111` (255)** 은  **특수한 용도**로 **예약되어 있음**  
→ 그래서 **정규화된 수(normalized numbers)** 에서 실제로 사용할 수 있는 값은:

$$1∼254$$



#### ✅ Exponent 사용 범위와 의미

| 항목         | Exponent 비트값     | 실제 지수 (`E = exp - 127`) | Fraction                | 의미                         |
| ---------- | ---------------- | ----------------------- | ----------------------- | -------------------------- |
| **최소 정규값** | `00000001` (1)   | **-126**                | `0...0`                 | `1.0 × 2⁻¹²⁶` ≈ ±1.2×10⁻³⁸ |
| **최대 정규값** | `11111110` (254) | **+127**                | `1...1` (≈ 0.999999...) | ≈ `2.0 × 2¹²⁷` ≈ ±3.4×10³⁸ |
| **예약값**    | `00000000`       | —                       | —                       | **denormalized**, ±0       |
| **예약값**    | `11111111`       | —                       | —                       | **Infinity**, **NaN**      |


#### ✅ 왜 이렇게 구성했을까?

- **Bias (127)** 를 중심으로 음/양 지수 범위를 **대칭적으로** 표현
- 지수 전체는 `0~255`, 실제 사용 가능한 지수는 `-126 ~ +127`
- 가장 작은 정규 수 = `1.0 × 2⁻¹²⁶`
- 가장 큰 정규 수 ≈ `2.0 × 2¹²⁷`
    

---
## **Double-Precision Range



---
## **Floating-Point Precision

정밀한 표현 여부 (유효 숫자 표현 여부)

- **Single (fp32)**  
  소수점 아래 **23자리**까지 표현 가능  → **10진수 기준 약 6~7자리**
    
- **Double (fp64)**  
  소수점 아래 **52자리**까지 표현 가능  → **10진수 기준 약 16자리 정도**

---
## **Floating Point Example1

-0.72 = - ( 1/2 + 1/4)

- 0.5 = 2⁻¹ → 첫 번째 자리 1
- 0.25 = 2⁻² → 두 번째 자리 1  
    → 0.75 = 0.5 + 0.25 = **0.11₂**

---
## **Floating Point Example2

(1+01_2) = 1.01_2



---
## **Integet vs. Floating Point Example

![](../images/Pasted%20image%2020250403130604.png)
1.



2.
int의 숫자가 너무 크면 float으로 변환할 때 숫자가 누락될 수 있음
표현할 수 있는 숫자는 많은데.. 숫자가 커질수록 숫자가 누락될 수 있음