---

---

데이터베이스는 엔티티들의 집합과 엔티티 사이의 관계에 의해 생성될 수 있다.

엔티티란 존재하는 객체로, 다른 객체들과 구별 가능한 대상을 의미한다.
예시 : 특정한 사람, 회사, 사건, 식물 등

엔티티들은 하나 이상의 속성을 가진다. 
속성은 엔티티의 특성을 설명하는 값이다.
예시 : 사람들은 그들의 이름과 주소를 가지고 있다. 

**엔티티 집합**은 **같은 유형(type)** 을 가지며, **같은 속성(attribute)** 을 공유하는 **엔티티들의 모음**이다.
예시: 모든 사람들의 집합, 모든 회사, 모든 나무, 모든 공휴일 등

![](../images/Pasted%20image%2020250414191101.png)

---
## **Attributes**

**엔터티(Entity)** 는 현실 세계의 객체나 개념을 의미하며,  **공통된 속성 집합으로 표현**된다.  즉, 엔터티는 **모든 구성원이 공유하는 기술적 속성들의 모음**이다.

- `instructor` = (ID, name, street, city, salary)
- `course` = (course_id, title, credits)

##### **도메인(Domain)**

- 각 속성은 특정 **도메인(domain)** 을 가지며,  이는 해당 속성에 허용되는 **값들의 집합**이다.  
	예: `salary`는 숫자형, `name`은 문자열 등
    

#### 속성의 유형

1. **단순(Simple) vs. 복합(Composite) 속성**
    
    - 단순: 더 이상 나눌 수 없는 속성 (예: `salary`)
        
    - 복합: 여러 하위 속성으로 구성됨 (예: `address` → `street`, `city`, `zip`)
        
2. **단일값(Single-valued) vs. 다중값(Multivalued) 속성**
    
    - 단일값: 하나의 값만 가짐 (예: `name`)
        
    - 다중값: 여러 값을 가질 수 있음 (예: `{phone_numbers}`)
        
3. **파생(Derived) 속성**
    
    - 다른 속성으로부터 **계산 가능한 속성**
        
    - 예: `age`는 `date_of_birth`로부터 계산됨
        
![](../images/Pasted%20image%2020250414191203.png)

---
## **Realationship Sets**

**관계(relationship)** 란, **둘 이상의 엔티티들 간의 연관성 또는 협력 관계**를 의미한다

```sql
44553 (Peltier) advisor 22222 (Einstein)
```

여기서 `44553 (Peltier)`는 학생(student) 엔터티,  `22222 (Einstein)`은 교수(instructor) 엔터티이며,  `advisor`는 이 둘을 연결하는 **관계**이다.


##### 관계 집합 ( Relationship Set )

**관계 집합(relationship set)** 은 **n ≥ 2개의 엔터티들로 구성된 수학적 관계**이다.
각 엔터티는 각각의 **엔터티 집합(entity set)** 에서 선택된다. 즉, 관계 집합은 **특정 타입의 엔터티들 사이에서 실제 발생한 관계들을 모아 놓은 집합**이다.

---
## **E-R Diagrams**

![](../images/Pasted%20image%2020250414191648.png)

- **직사각형(Rectangle)** → **엔터티 집합(Entity Set)** 을 나타낸다.
- **마름모(Diamond)** → **관계 집합(Relationship Set)** 을 나타낸다.
- 속성은 **엔터티를 나타내는 직사각형에 연결되어** 표현된다.
- **밑줄(Underline)** → **기본 키(Primary Key)** 속성을 의미한다.

---
## **Relationship Sets**

**관계 자체에 대한 정보를 담는 속성(descriptive attributes)** 도 가질 수 있다.

![](../images/Pasted%20image%2020250414191957.png)

예를 들어, **교수(instructor)** 와 **학생(student)** 사이의 `advisor` 관계를 생각해보자. 
이 관계는 단순히 "어떤 교수가 어떤 학생의 지도교수인가"를 나타내는 것뿐만 아니라,  **해당 관계가 형성된 시점** 같은 정보를 함께 표현할 수 있다.

관계는 참여하는 엔터티들에 의해서만 식별된다. 즉, 관계 인스턴스(한 개의 관계 튜플)는 **참여하고 있는 각 엔터티 인스턴스들의 조합**으로 구분된다

---
## **Degree of a Realtionship Set**

**Binary Relationship** 은 **두 개의 엔터티 집합(entity set)** 사이의 관계를 의미한다. - 즉, 한 관계 인스턴스는 **두 개의 엔터티**를 연결한다.

- 데이터베이스 시스템에서 정의되는 **대부분의 관계는 binary** 관계이다.

- 실제로, 데이터베이스 설계에서 **두 엔터티 간의 관계가 가장 일반적이며 흔하다.**

- 세 개 이상의 엔터티를 동시에 포함하는 **다항(n-ary) 관계(n ≥ 3)** 도 존재할 수는 있지만, **드물게 사용된다.**

- 따라서 **데이터베이스 시스템에서 지원되는 관계의 최대 형태는 대부분 binary** 라고 볼 수 있다.

---
## **Ternary Relationship**

**학생(student)** 들은 **교수(instructor)** 의 지도 하에 **연구 프로젝트(project)** 를 수행한다고 가정하자. 이 상황은 다음과 같은 **삼항(3-way) 관계**로 표현할 수 있다.

여기서 `proj_guide`는 **instructor**, **student**, **project** 세 엔터티 집합 간의 **삼항 관계(ternary relationship)** 이다.

![](../images/Pasted%20image%2020250414192605.png)

---
## **Roles**

하나의 **관계(relationship)** 에 참여하는 **엔터티 집합(entity set)** 들은 **서로 구별되는(vdistinct) 집합일 필요는 없다.** 즉, **동일한 엔터티 집합이 같은 관계 안에서 여러 번 등장할 수 있다.**

동일한 엔터티 집합이 여러 번 참여할 경우,  각 엔터티는 **관계 내에서 특정한 역할(role)** 을 수행한다. 이때 **각 등장마다의 의미를 명확히 하기 위해 역할 이름을 부여**한다.

![](../images/Pasted%20image%2020250414193101.png)

예를 들어, 어떤 과목이 다른 과목을 선수 과목으로 요구하는 `prereq` 관계에서는  
`course` 엔터티가 두 번 등장하며, 각각 `course_id`, `prereq_id`라는 **역할 이름**으로 구분된다.

---
## **Mapping Carinality Constraints**

하나의 엔터티가 **관계 집합을 통해 다른 엔터티들과 몇 개까지 연결될 수 있는지**를 나타낸다.

이 개념은 **이항 관계 집합(binary relationship set)** 을 설명할 때 특히 유용하다.

이항 관계의 경우, 매핑 카디널리티는 다음 네 가지 중 하나로 분류된다:

- 일대일 (one to one)
    
- 일대다 (one to many)
    
- 다대일 (many to one)
    
- 다대다 (many to many).

![](../images/Pasted%20image%2020250414193903.png)

![](../images/Pasted%20image%2020250414193926.png)

---
relationship set과 entity set 사이에서 화살표 직선(directed line)인 경우에 일, 그냥 직선인 경우 다에 해당한다.

일대일 관계
학생은 advisor 관계를 통해 최대 하나의 교수님과 연관되어있다.
학생은 stud_dept를 통해 최대 하나의 학과에 연관되어있다. 

---
Cardinality Constraints on Ternary Relationship

instuctor project student

p 에 화살표 있을 때

i1 s2 p1 
i1 s2 p2  -> 불가능
i2 s2 p1  -> 이건 가능

i1 s2 p1 , i1 s2 p2 여기서는 같고
i1 s2 랑 i2 s2랑 다르기 때문에 가능

화살표는 하나만 있어야 됨
여러개라면 다중의미를 가지기 때문!

---
## **Weak Entity Sets**

엔티티에 pk가 없는 경우 weak entity set이라고 한다.

약한 엔터티 집합은 **식별(identifying) 엔터티 집합**의 존재에 **의존**한다. 즉, **자체적인 기본 키(primary key)가 없으며**,  **강한 엔터티 집합의 기본 키에 의존하여 식별**된다.

약한 엔터티는 **식별 엔터티와 반드시 전사(total) 관계**를 가져야 하며, 이 관계는 **강한 엔터티 → 약한 엔터티 방향의 1:N 관계**여야 한다.  이 관계를 **식별 관계(identifying relationship)** 라고 하며, ER 다이어그램에서는 **이중 마름모(double diamond)** 로 표현된다.

#### ✅** 약한 엔터티 집합의 식별자**

**Discriminator(또는 Partial Key)** 는  약한 엔터티 집합 내에서 **각 개체를 서로 구분**하기 위한 속성들의 집합이다. 이 속성들만으로는 전체 데이터베이스 내에서 유일하지 않지만, **식별 엔터티의 기본 키와 결합하면 유일하게 식별**할 수 있다.

#### **✅ 약한 엔터티 집합의 기본 키 구성**

약한 엔터티의 **기본 키는 두 부분으로 구성**된다:
    
1. **식별(강한) 엔터티 집합의 기본 키**
        
2. **약한 엔터티 자신의 식별자(Discriminator)**
        
이 두 요소의 결합을 통해 약한 엔터티의 각 튜플을 **고유하게 식별**할 수 있다.

![](../images/Pasted%20image%2020250410154606.png)


약한 엔터티의 **식별자(Discriminator)** 는 **점선 밑줄(dashed underline)** 로 표시한다.  
→ 이는 **기본 키  전체는 아니지만**, **엔터티 내부에서 구분 역할**을 한다는 점을 나타낸다.

`section`은 **약한 엔터티 집합**이기 때문에 **단독으로 기본 키를 가질 수 없다.**  
따라서, 식별 관계에 있는 **강한 엔터티 `course`의 기본 키인 `course_id`** 와  
`section` 자신의 식별자 역할을 하는 `sec_id`, `semester`, `year`를 **함께 조합하여 기본 키**를 구성해야 한다.

#### **✅ 강한 엔티티의 기본 키가 직접 표현되지 않는다**

**강한 엔티티의 기본 키는 외형적으로 약한 엔티티에 저장되는 것이 아니다.**  
왜냐하면 **식별 관계(identifying relationship)를 통해 암묵적으로 포함(implicit)** 되기 때문이다.

즉, 약한 엔티티의 기본 키는 **식별 관계를 통해 연결된 강한 엔티티의 기본 키 + 자신의 식별자(discriminator)** 로 구성되지만,  그 구조는 **관계 모델에서 명시적으로 표현될 뿐**, ER 다이어그램에서는  **강한 엔티티의 키가 약한 엔티티 내부에 반복되어 나타나지는 않는다.**

만약 `course_id`가 `section` 엔터티에 **명시적으로 저장된다면**,  `section`은 더 이상 약한 엔터티가 아니라 **강한 엔터티로 만들 수 있다.**

하지만 이 경우, `course`와 `section` 사이의 관계는 **`course_id` 속성을 통한 암묵적인 관계**와**원래의 식별 관계** 이렇게 **두 번 표현되는 중복된 관계**가 발생하게 된다.

즉, `course_id`가 `section`에 명시적으로 포함되면,  **두 테이블 간의 관계가 속성 자체를 통해 이미 표현되므로**,  별도로 식별 관계를 두는 것이 **논리적 또는 설계적으로 중복**이 될 수 있다.



---

Multivalued Attributes (Cont.)



time_slot(<u>time_slot_id</u> { day, start_time, end_time})

time_slot(<u>time_slot_id</u>)
time_slot_days(<u>time_slot_id, day, start_time</u>, end_time) -> 최적화

최종 스키마에서는 time_slot(<u>time_slot_id</u>) 이걸 제거 했기 때문에 사실 section 안에 있는 time_slot_id 는 fk가 될 수 없다. 또 pk 중에 일부라서 fk가 될 수 없기도 함,, 중간에 time_slot(<u>time_slot_id</u>) 테이블이 있다면 할 수 있을 지도?


항상 이런 경우가 발생하는건 아님! 

---
## **Representing Relationship Sets**

**다대다 관계(M:N relationship)** 는 두 개의 엔터티 집합 간에 여러 개의 대응 관계가 있을 수 있는 구조이다. 이러한 관계는 **관계 스키마**로 표현되며, 다음과 같은 요소들을 포함한다

- 관계에 참여하는 **두 엔터티 집합의 기본 키** (각각 외래 키로 사용됨)
    
- 관계 자체의 **서술적 속성(선택적)**

takes ( <u><u>ID</u>, course_id, sec_id, semester, year,</u> grade )
teaches ( ID, sec_id, semester, year )

---
## **Redundancy of Schemas**

