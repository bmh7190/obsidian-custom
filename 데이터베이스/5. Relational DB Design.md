어떤게 좋은 Realational Design 인가?
좋은 Realtional Design은 Normal Form을 가진다! 

1 NF : 관계형 모델에서 어떤 속성의 값이던지 atomic해야 한다. 
2 NF
3 NF
BC NF 

밑 단계로 갈 수록 제약 조건이 많아진다. 
위 단계를 만족한 상태이다.
less redundant

---
## **Combine Schemas?**

중복이 야기하는 2가지 문제점

inconsitency
inefficiency

department_name 이 정해지면 building 과 budget에 의해 정해진다. 
이게 문제임

![](../images/Pasted%20image%2020250415141545.png)

---
## **What About Smaller Schemas?**

예를 들어, 우리가 처음부터 `big_instructor`라는 스키마로 시작했다고 가정해보자.  그렇다면 어떻게 이를 `instructor`와 `department`로 **분해(decompose)** 해야 한다는 것을 알 수 있을까?

##### **함수 종속성(Functional Dependency)을 이용한 분해 판단**

다음과 같은 규칙을 생각해볼 수 있다:

> **“만약 (dept_name, building, budget)이라는 스키마가 존재한다면, `dept_name`은 후보 키(candidate key)가 되어야 한다.”**

이 의미를 함수 종속성으로 표현하면 다음과 같다:

`dept_name → building, budget`  

이 종속성은 **하나의 학과 이름(`dept_name`)에 대해 건물(`building`)과 예산(`budget`)이 결정됨**을 의미한다.  하지만 `big_instructor`에서는 `dept_name`이 **후보 키가 아니기 때문에**,  하나의 학과에 대해 **building과 budget 정보가 반복해서 저장될 수 있다.**

이러한 중복은 **정규화(normalization)** 가 필요함을 의미하며,  따라서 `big_instructor`는 다음과 같이 **두 개의 릴레이션으로 분해**하는 것이 바람직하다:

- `instructor(ID, name, salary, dept_name)`
    
- `department(dept_name, building, budget)`

##### 분해가 항상 바람직한 것은 아니다.
모든 분해가 정당한 것은 아니다. 예를 들어, 다음과 같이 잘못 분해하면 문제가 발생한다:

```sql
employee(ID, name, street, city, salary)
→ employee1(ID, name)
→ employee2(name, street, city, salary)
```

이 경우, name은 유일한 속성이 아니기 때문에, employee1과 employee2를 조인할 때 잘못된 데이터가 결합되거나 손실될 수 있다.


---
## **A Lossy Decomposition**

정보가 손실된다는 것은,  **원래의 `employee` 릴레이션을 정확하게 복원할 수 없다는 것**을 의미한다.  이러한 경우, 해당 분해는 **정보 손실 분해(lossy decomposition)** 라고 한다.

즉, 잘못 분해된 결과는 **원래 릴레이션과 동일한 정보를 담지 못하고**,  **불필요한 튜플이 생기거나, 일부 정보가 사라지는 문제**를 유발할 수 있다.

![](../images/Pasted%20image%2020250415142447.png)

---
## **Example of Lossless-Join Decomposition**

![](../images/Pasted%20image%2020250415193802.png)

릴레이션을 분해할 때,  **공통 속성 중 적어도 하나는 어느 한 릴레이션에서 기본 키 역할을 해야** 원래 릴레이션을 정확히 복원할 수 있다. 그렇지 않으면, **Lossy Decomposition (정보 손실 분해)** 이 발생할 수 있다.


---
## **First Normal Form**

어떤 관계 스키마 `R`이 **제1정규형(1NF)** 에 속한다는 것은, `R`의 모든 속성이 **원자적인 도메인**을 가져야 함을 의미한다. 여기서 **도메인이 원자적(atomic)** 이라는 말은, 해당 도메인의 각 값이 **더 이상 나눌 수 없는 단위**로 간주된다는 뜻이다.

만약 값이 원자적이지 않다면, 즉 하나의 속성 값이 여러 개의 값을 포함하고 있다면, 데이터를 **저장하거나 검색하기가 복잡**해지고,**중복된 정보가 저장**될 가능성이 높아진다.

> [!example]
> 각각의 손님에 대해서 여러 개의 계좌 목록을 저장하고, 각각의 계좌에는 여러 명의 소유자가 저장된다고 해보자. 이 경우 한 속성 안에 리스트나 집합처럼 다수의 값이 포함되면 이는 더 이상 원자적이지 않다. 따라서 제1정규형을 만족하려면, 이러한 복합 정보를 별도의 관계,테이블로 분리하고, 각 속성에는 **단 하나의 원자값만** 저장되도록 해야 한다.


##### 원자성은 **도메인이 실제로 어떻게 사용되는지**에 따라 결정된다.

예를 들어, 문자열(string)은 일반적으로 더 이상 나눌 수 없는 원자값으로 간주된다. 그런데 학생들이 CS0012나 EE1127 같은 형태의 '역할 번호(Role ID)'를 부여받았다고 가정해 보자. 만약 이 문자열에서 앞의 두 문자를 떼어내 학과 정보를 알아내려 한다면, 사실상 이 '역할 번호'라는 도메인은 원자적이지 않은 셈이 된다.

이처럼 하나의 도메인 안에 여러 의미가 ‘인코딩’되어 있으면 관리가 복잡해지고, 데이터베이스 설계에서도 바람직하지 않다. 즉, 도메인이 원자적인지 여부는 단순히 데이터 형태(문자열인지, 숫자인지 등)가 아니라 **그 값을 실제로 어떻게 활용하는지**에 달려 있음을 유념해야 한다.

---
## **Goal - Devis a Theory for the Following**

릴레이션이 **좋은 형태**라는 것은, 일반적으로 적절한 **정규형(normal form)** 을 만족하는지를 의미한다.

- 어떤 릴레이션 `R`이 **좋은 형태(good form)**인지 판단한다.  
- 만약 릴레이션 `R`이 좋은 형태가 아니라면, `R`을 `R1`, `R2`, ..., `Rn`과 같은 릴레이션들의 집합으로 **분해(decomposition)** 한다.  
- 이때, 각 릴레이션은 **좋은 형태**를 만족해야 하며, 이 분해는 반드시 **손실 없는 조인 분해(lossless join decomposition)** 가 되어야 한다.

우리가 사용하는 이 이론은 **함수적 종속성(functional dependencies)** 에 기반한다.

---
## **Functional Dependencies**

**합법적인 릴레이션들의 집합에 대한 제약 조건**은  
특정 속성 집합의 값이 **다른 속성 집합의 값을 유일하게 결정해야 함**을 요구한다.

이러한 개념을 **함수적 종속성(Functional Dependency)** 이라고 하며,  
이는 **키(key)** 개념의 **일반화**이다. 

---

릴레이션 스키마 `R`이 있다고 하자.  

`α ⊆ R`이고 `β ⊆ R`일 때,  
>α와 β는 R의 속성들 중 일부를 선택한 집합이다.

**함수적 종속성** `α → β`가 `R`에서 **성립한다**는 것은 다음과 같은 의미이다.

> 모든 합법적인 릴레이션 인스턴스 `r(R)`에 대해,  
> 어떤 두 튜플 `t₁`과 `t₂`가 `α` 속성들에 대해 동일한 값을 가진다면,  
> `β` 속성들에 대해서도 반드시 동일한 값을 가져야 한다.


```
t₁[α] = t₂[α] ⇒ t₁[β] = t₂[β]
```


릴레이션 `r(A, B)`의 한 인스턴스가 다음과 같다고 하자.  

![](../images/Pasted%20image%2020250416102614.png)

이 경우, **`A → B`는 성립하지 않지만**,  **`B → A`는 성립한다.**
A의 값이 같아도 B는 4와 5로 값이 다르다. 그래서 `A → B` 은 성립하지 않는다.
하지만 B는 중복되지 않고, 유일한 A 값과 연결되므로 **`B → A`는 성립한다.** 라고 할 수 있다. 