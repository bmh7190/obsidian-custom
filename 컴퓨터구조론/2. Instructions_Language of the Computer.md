

---
### 🏛️ Instruction Set

**Instruction Set**은 컴퓨터가 수행할 수 있는 기능들의 집합이다.  
각 컴퓨터마다 고유한 **Instruction Set**을 가지지만, 기본적인 동작 원리는 유사하다.  
초기 컴퓨터들은 매우 단순한 Instruction Set을 가지고 있었으며,  
오늘날의 많은 현대 컴퓨터들도 여전히 간결한 Instruction Set을 유지하고 있다.

---

### 🔢 Arithmetic Operations

**덧셈(Add)과 뺄셈(Subtract)** 연산은 **3개의 피연산자(Operands)**를 사용한다.

- **두 개(Source)**는 연산할 값이고,
- **하나(Destination)**는 결과를 저장할 레지스터이다.

assembly

복사편집

`add a, b, c  # a ← b + c sub a, b, c  # a ← b - c`

모든 산술 연산(Arithmetic Operations)은 이와 같은 형식을 따른다.

> **📌 Design Principle 1**: 단순한 연산일수록 규칙적인 형식을 따르는 것이 좋다.

---

### 📌 Register Operands

산술 연산(Arithmetic Instructions)은 **레지스터(Register)**를 사용하여 데이터를 처리한다.  
MIPS 프로세서는 **32개의 32비트 레지스터 파일(Register File)**을 제공하며,  
이는 **자주 사용되는 데이터**를 저장하는 용도로 활용된다.

- 레지스터는 **0번부터 31번까지 번호가 부여**되며,
- 32비트 데이터 단위를 **워드(Word)**라고 부른다.

💾 **어셈블러(Assembler)에서 사용하는 레지스터 명칭**

- `$t0, $t1, ... , $t9` → **임시 값(Temporary Values) 저장**
- `$s0, $s1, ... , $s7` → **저장된 변수(Saved Variables) 저장**

> **📌 Design Principle 2**: **레지스터 크기가 작을수록 연산 속도는 더 빨라진다.**

---
### 🖥️ **Main Memory for Composite Data**

산술 연산(Arithmetic Operations)을 적용하기 위해, **메인 메모리(Main Memory)**를 사용하여 데이터를 불러오거나 저장할 수 있다.

#### **📌 메모리에서 데이터 로드 및 저장**

```assembly
lw $t0, 8($s1)  # 메모리에서 값을 불러와 $t0에 저장 (Load Word) 
sw $t0, 8($s1)  # $t0의 값을 메모리에 저장 (Store Word)`
```

- `lw (Load Word)` : 메모리에서 데이터를 불러와 레지스터에 저장
- `sw (Store Word)` : 레지스터 값을 다시 메모리에 저장

---

### 📌 **메모리 주소와 데이터 정렬**

✅ **MIPS의 메모리 특성**

- **메모리는 바이트(Byte) 단위로 주소가 할당됨**
- **각 주소(Address)는 8비트(1바이트) 데이터를 가리킴**
- **워드(Word)는 메모리에 정렬(Aligned)되어 저장됨**
- **주소는 항상 4의 배수(Multiple of 4)여야 함**

✅ **MIPS는 Big Endian 방식을 사용**

- 워드(Word) 내에서 **가장 큰 값(Most Significant Byte, MSB)**이 **가장 작은 주소(Least Address)**에 저장됨

📌 **정리하면:**

- 메모리는 **바이트 주소로 관리**되며,
- **4바이트 정렬**을 유지해야 하며,
- **MIPS는 빅 엔디언(Big Endian) 방식**을 따른다.

---
### Littele vs Big endian

Example
- vaiable x has 4-byte value of 0x01234567
- Address given by &x is 0x100

![](../images/Pasted%20image%2020250319102729.png)


- **Big Endian**: 주소가 작은 곳부터 **가장 큰 값**이 저장되고, 점점 작은 값이 뒤에 배치된다.
- **Little Endian**: 주소가 작은 곳부터 **가장 작은 값**이 저장되고, 점점 큰 값이 뒤에 배치된다.


---

### Memory Operand Example 1

#### C Code

```c
g = h + A[8];
```

- `g` → `$s1`
- `h` → `$s2`
- `A` 배열의 **베이스 주소** → `$s3`

#### Compiled MIPS Code

```assembly

# 배열 A의 인덱스 8은 오프셋 32를 필요로 함 
# (4바이트 * 8 = 32) 
lw $t0, 32($s3)   # A[8]의 값을 로드하여 $t0에 저장 
add $s1, $s2, $t0 # g = h + A[8]

```

- 배열은 **4바이트(Word) 단위**로 저장되므로,  
- 인덱스 8에 해당하는 메모리 오프셋은 `8 × 4 = 32` 바이트가 됨.
- `lw` 명령어를 사용해 `A[8]`의 값을 `$t0`에 로드한 후,
- `add` 명령어로 `h`와 `A[8]`을 더해 `g`에 저장.

---
### Memory Operand Example2

#### C Code

```c
A[12] = h + A[8]
```

- `h` → `$s2`
- `A` 배열의 **베이스 주소** → `$s3`

#### Compiled MIPS Code

```assembly

# 배열 A의 인덱스 8은 오프셋 32를 필요로 함 
# (4바이트 * 8 = 32) 

lw $t0, 32($s3)   # A[8]의 값을 로드하여 $t0에 저장 
add $$t0, $s2, $t0
sw $t0, 48($s3)

```

- 배열은 **4바이트(Word) 단위**로 저장되므로,  
- 인덱스 8에 해당하는 메모리 오프셋은 `8 × 4 = 32` 바이트가 됨.
- `lw` 명령어를 사용해 `A[8]`의 값을 `$t0`에 로드한 후,
- `add` 명령어로 `h`와 `A[8]`을 더해 `$t0`에 저장.
- 인덱스 12에 해당하는 메모리 오프셋은 `12 × 4 = 48` 바이트가 됨.
- `sw` 명령어를 사용해 `A[12]`에 `$t0`를 저장.


---
### Registers vs. Memory

- **레지스터(Register)**는 **메모리보다 더 빠르게** 접근할 수 있음.
- 메모리에서 데이터를 가져오거나 저장하는 작업은 **`load`와 `store` 명령어**가 필요하며, 이는 **더 많은 명령어 실행**을 요구함.

#### **컴파일러의 역할**

컴파일러는 가능한 한 **많은 변수**를 **레지스터**에 할당해야 함.

- **자주 사용되지 않는 변수**만 메모리에 저장 (spill)
- **레지스터 최적화**가 성능에 중요한 영향을 미침

---
### Immediate Operands

- 상수(Constant) 데이터를 **명령어 내부에서 직접 지정**할 수 있음.
    ```assembly
    addi $s3, $s3, 4  # $s3에 4를 더함
    ```
    

#### Subtraction with Immediate Values

MIPS에는 **subtract immediate(`subi`) 명령어가 없음**.  
대신 **음수 상수(negative constant)**를 사용하여 뺄셈을 수행함.

```assembly
addi $s2, $s1, -1  # $s2 = $s1 - 1
```

 
> **📌 Design Principle 3: ** 보통의 경우에 더 빠르게 하라
- 작은 상수(Small Constants)는 **자주 사용됨**.
- **Immediate Operand**를 사용하면 **추가적인 load 명령어 없이** 빠르게 연산 가능.

---
### The Constant Zero

- MIPS의 **레지스터 0(`$zero`)**는 항상 **상수 0**을 저장하고 있음.
- 값을 변경할 수 없음 (**cannot be overwritten**).
- 일반적인 연산에서 유용하게 활용됨.

---
### Unsigned Binary Integers

**n비트의 부호 없는 이진 정수(Unsigned Binary Integer)**는 다음과 같은 식으로 표현됨:

$$x=xn−1⋅2n−1+xn−2⋅2n−2+⋯+x1⋅21+x0⋅20x = x_{n-1} \cdot 2^{n-1} + x_{n-2} \cdot 2^{n-2} + \dots + x_1 \cdot 2^1 + x_0 \cdot 2^0$$

모든 비트가 **크기를 나타내는 값**으로 사용되며, **부호 비트(Sign Bit)가 없음**.

---

### **범위 계산**

$$0≤x≤2n−10 \leq x \leq 2^n - 1$$

- 4비트: `0` ~ `15`
- 8비트: `0` ~ `255`
- 16비트: `0` ~ `65,535`
- 32비트: `0` ~ `4,294,967,295`

---
### Signed Binary Integers

부호 있는 정수(Signed Integer)는 **이진수 표현**에서 가장 높은 비트(MSB, Most Significant Bit)를 **부호 비트(Sign Bit)**로 사용하여 음수를 표현할 수 있음.

#### **2의 보수(Two’s Complement) 표현**

n비트의 정수 `x`는 다음과 같이 나타냄:

$$x=−xn−1⋅2n−1+xn−2⋅2n−2+⋯+x1⋅21+x0⋅20x = -x_{n-1} \cdot 2^{n-1} + x_{n-2} \cdot 2^{n-2} + \dots + x_1 \cdot 2^1 + x_0 \cdot 2^0$$


- `x_{n-1}`: **부호 비트(Sign Bit)**
    - `0`: 양수
    - `1`: 음수
- 나머지 비트는 **크기를 나타내는 값**

#### **예제: 4비트 Signed Integer**

| 2진수    | 10진수 해석                                                                                  | 값    |
| ------ | ---------------------------------------------------------------------------------------- | ---- |
| `0111` | $$ 0×(−23)+1×22+1×21+1×200 \times (-2^3) + 1 \times 2^2 + 1 \times 2^1 + 1 \times 2^0 $$ | `+7` |
| `0001` | $$0×(−23)+0×22+0×21+1×200 \times (-2^3) + 0 \times 2^2 + 0 \times 2^1 + 1 \times 2^0$$   | `+1` |
| `0000` | $$0×(−23)+0×22+0×21+0×200 \times (-2^3) + 0 \times 2^2 + 0 \times 2^1 + 0 \times 2^0$$   | `0`  |
| `1111` | $$1×(−23)+1×22+1×21+1×201 \times (-2^3) + 1 \times 2^2 + 1 \times 2^1 + 1 \times 2^0$$   | `-1` |
| `1000` | $$1×(−23)+0×22+0×21+0×201 \times (-2^3) + 0 \times 2^2 + 0 \times 2^1 + 0 \times 2^0$$   | `-8` |

#### Specific numbers
- 0 : 0000 0000 ... 0000
- -1 : 1111 1111 ... 1111
- Most-negative : 1000 0000 ... 0000
- Most-positive : 0111 1111 ... 1111

---
### Signed Negation

#### 2의 보수(Two’s Complement) 방식으로 음수 표현

1. **1의 보수(Complement)**: 모든 비트를 반전 (1 → 0, 0 → 1)
2. **1을 더하기(Add 1)**

#### **수식**

x+x‾=1111...11112=−1x + \overline{x} = 1111...1111_2 = -1 x‾+1=−x\overline{x} + 1 = -x

#### **예제: +2를 음수로 변환**

1. **+2의 2진 표현:**
    
    ```
    0000 0000 ... 0010₂
    ```
    
2. **1의 보수 적용:**
    
    ```
    1111 1111 ... 1101₂
    ```
    
3. **1을 더함:**
    
    ```
    1111 1111 ... 1110₂
    ```
    
    → `-2`의 2의 보수 표현

---
### Sign Extension

#### **정수를 더 많은 비트로 표현**

- 숫자의 값을 유지하면서 비트 수를 늘리는 방법
- **부호(Sign Bit)를 유지해야 함**

#### **MIPS 명령어에서 사용되는 경우**

- `addi`: 즉시 값(Immediate Value) 확장
- `lb`, `lh`: 바이트(Byte) 또는 하프워드(Halfword) 로드 시 확장
- `beq`, `bne`: 분기(Branch) 시 변위(Displacement) 확장

#### **부호 확장의 원칙**

- **부호 비트를 왼쪽으로 복제**
- **부호 없는 값(Unsigned Value)**의 경우 **0을 추가**

#### **예제: 8비트를 16비트로 확장**

1. **양수 (+2)의 확장**
    
    ```
    0000 0010  →  0000 0000 0000 0010
    ```
    
2. **음수 (-2)의 확장**
    
    ```
    1111 1110  →  1111 1111 1111 1110
    ```
    

부호 확장을 통해 **음수는 그대로 음수로 유지되고, 양수는 값이 보존됨**.

---
# Representing Instructions

- 명령어는 **이진수(binary)** 로 인코딩된다.
- 이를 **머신 코드(machine code)** 라고 부른다.
- MIPS 명령어는 **32비트 길이의 명령어 워드(word)** 로 인코딩된다.
- 소수의 형식을 사용하여 연산 코드(opcode), 레지스터 번호 등을 표현한다.
- 포맷이 규칙적이어서 해석하기 쉽다.

### 🗂️ 레지스터 번호

| 이름          | 번호 범위 |
| ------------- | --------- |
| `$t0` ~ `$t7` | 8 ~ 15    |
| `$t8` ~ `$t9` | 24 ~ 25   |
| `$s0` ~ `$s7` | 16 ~ 23   |

---
# MIPS R-format instructions

![](../images/Pasted%20image%2020250326132437.png)


## Instuction fields

- **op** : 연산 코드 (operation code)
- **rs** : 첫 번째 소스 레지스터 번호 (first source register number)
- **rt** : 두 번째 소스 레지스터 번호 (second source register number)
- **rd** : 결과를 저장할 목적지 레지스터 번호 (destination register number)
- **shamt** : 쉬프트 양 (shift amount) → 현재는 `00000` 고정
- **funct** : 함수 코드 (function code) → opcode를 보완하여 연산을 구체화함

`opcode` 와 `funct` 를 함께 사용하여 어떤 명령어인지 구체적으로 표현한다.
레지스터는 총 **32개** 존재하며, 각각을 **5비트**로 표현한다.

## R-format Example

```assembly
add $t0, $s1, $s2
```

![](../images/Pasted%20image%2020250326132948.png)


`$s1` 레지스터와 `$s2` 레지스터의 값을 더해서 **$t0**에 저장하라는 의미

```
00000010001100100100000000100000
```

어셈블리어에서는 명령어를 `rd, rs, rt` 순서로 작성한다. 하지만 R-format으로 인코딩될 때는 레지스터가 `rs, rt, rd` 순서로 배치된다. 

---

# MIPS I-format Instructions

![](../images/Pasted%20image%2020250326133525.png)


## Imediate arithmetic and load/store instructions

- `rs`: 연산에 사용되는 **소스 레지스터**
- `rt`: 상황에 따라 **소스 또는 목적지 레지스터**로 사용됨
- `constant`: 16비트 상수값, 범위는 **-2¹⁵ ~ 2¹⁵ - 1**
- `address`: 메모리 접근 시 사용하는 **주소 오프셋(offset)**

![](../images/Pasted%20image%2020250326133823.png)



#### ✅ `lw` (load word)

- **형태**: `lw rt, offset(rs)`
- **기능**: `rs`가 가리키는 메모리 주소에서 `offset`만큼 떨어진 곳에 있는 **값을 읽어**와서 `rt`에 저장
- **역할**: 메모리 → 레지스터
    
```assembly
lw $t0, 4($s1)
```
→ `$s1 + 4` 주소에 있는 값을 `$t0`에 로드
→ 여기서 rt 목적지의 역할을 한다.

#### ✅ `sw` (store word)

- **형태**: `sw rt, offset(rs)`
- **기능**: `rt`에 있는 **값을 메모리에 저장**  / 주소는 `rs + offset`으로 계산
- **역할**: 레지스터 → 메모리

```assembly
sw $t0, 4($s1)
```

→ `$t0`의 값을 `$s1 + 4` 주소에 저장
→ 여기서 rt 는 source의 역할을 한다. 

#### ✅ `addi` (add immediate)

- **형태**: `addi rt, rs, immediate`
- **기능**: `rs`의 값과 `immediate` 값을 더해서 결과를 `rt`에 저장
- **역할**: 간단한 정수 덧셈

```assembly
addi $t0, $s1, 10
```

→ `$s1 + 10` 결과를 `$t0`에 저장


---
# Stored Program Computers

<div style="display: flex; align-items: flex-start;">
  <div style="margin-right: 20px;">
    <h3>The BIG Picture</h3>
    명령어는 <strong>데이터처럼 이진수(binary)</strong>로 표현된다.  
    <ul>
      <li>명령어와 데이터는 <strong>모두 메모리에 저장</strong>된다.</li>
      <li>프로그램들은 <strong>다른 프로그램(컴파일러, 링커 등)</strong> 안에서 동작한다.</li>
      <li><strong>바이너리 호환성(binary compatibility)</strong> 덕분에, 컴파일된 프로그램은 <strong>다른 컴퓨터에서도 실행 가능</strong>하다.</li>
    </ul>
  </div>
  <img src="Pasted image 20250326140149.png" alt="The BIG Picture" width="250">
</div>


---
# Memory Layout

- **Text**: 프로그램 코드가 저장되는 영역
- **Static data**: 전역 변수(static/global variables)가 저장되는 영역
- **Dynamic data**: 동적 메모리(Heap)가 저장되는 영역 (`malloc` 등으로 할당됨)
- **Stack**: 함수 호출 시 사용되는 자동 저장 공간 (지역 변수, 리턴 주소 등)

![](../images/Pasted%20image%2020250326141623.png)



---
# Logical Operations

![](../images/Pasted%20image%2020250326141813.png)



## Shift Operations

![](../images/Pasted%20image%2020250326142437.png)


#### ✅ Shift Left Logical (`sll`)

- **op = 0**, **funct = 0**
- 왼쪽으로 i비트 쉬프트하고, **빈 자리는 0으로 채움**
- `sll` by `i` bits → **2ⁱ 배 곱하기**
- **사용 예시**: 곱셈을 빠르게 수행할 때

#### ✅ Shift Right Logical (`srl`)

- **op = 0**, **funct = 2**
- 오른쪽으로 i비트 쉬프트하고, **빈 자리는 0으로 채움**
- `srl` by `i` bits → **2ⁱ로 나누기 (정수 나눗셈)**
- **unsigned 정수 전용**

![](../images/Pasted%20image%2020250326142802.png)


```assembly
sll $t2, $s0, 4   # $t2 = $s0 << 4  (왼쪽으로 4비트 shift)
srl $t2, $s0, 4   # $t2 = $s0 >> 4  (오른쪽으로 4비트 shift)
```

💡 의미:
`sll`: `$s0` 값을 왼쪽으로 4비트 이동, 빈 자리는 0으로 채움 -> 결과를 `$t2`에 저장
`srl`: `$s0` 값을 오른쪽으로 4비트 이동, 빈 자리는 0으로 채움 -> 결과를 `$t2`에 저장

## AND Operations

- **AND 연산은 특정 비트만 선택(select)** 하고, 나머지 비트는 **0으로 초기화(clear)** 하는 데 유용함
- 주로 **마스킹(masking)** 작업에 사용됨
- 한 워드(word)에서 원하는 비트만 남기고, **다른 비트는 모두 0으로 만든다**

![](../images/Pasted%20image%2020250326143135.png)


- `$t1`과 `$t2`를 비트 단위로 **AND 연산**해서 결과를 `$t0`에 저장
- 각 비트 위치에서 둘 다 1일 때만 1이 됨, 나머지는 0


## OR Operations 

- 특정 비트를 **1로 설정(set)** 할 때 유용함
- 원하는 비트만 1로 만들고, **나머지 비트는 그대로 유지**
- 워드(word) 안에서 **특정 비트를 포함(include)** 시키는 데 사용됨

![](../images/Pasted%20image%2020250326143455.png)


- `$t1`과 `$t2`를 **비트 단위 OR 연산**해서 결과를 `$t0`에 저장
- **하나라도 1인 자리**는 결과도 1이 됨


## NOT Operations

- 비트를 **반전(invert)** 시킬 때 사용됨
- **0 → 1**, **1 → 0** 으로 바뀜
- 워드(word) 내의 모든 비트를 뒤집는 데 유용함
- MIPS에는 단독 `NOT` 명령어가 없음 대신, **`NOR` 명령어**를 이용해 `NOT` 연산을 구현함 
- `nor`은 3-operand 연산으로 동작함
	- `a nor b  ≡  not (a OR b)`
	→ 즉, `a`와 `b`를 OR 한 다음, **그 결과를 NOT** 하는 것

![](../images/Pasted%20image%2020250326143830.png)


---
# Conditional Operations

```assembly
beq rs, rt, L1
```

- `rs`와 `rt`가 **같으면** → 레이블 `L1`으로 분기
- **조건 분기 (equal)**
- **I-format** 사용

```assembly
bne rs, rt, L1
```

- `rs`와 `rt`가 **다르면** → 레이블 `L1`으로 분기
- **조건 분기 (not equal)**
- **I-format** 사용

```assembly
j L1
```

- 조건 없이 **무조건적으로** 레이블 `L1`로 점프
- **J-format** 사용

![](../images/Pasted%20image%2020250326144439.png)


---
# Compiling If Statements

```C
if ( i == j ) f = g + h;
else f = g - h;

f, g, ... in `$s0`, `$s1`, ...

```


```assembly
bne $s3, $s4, Else     # if (i != j) -> else로 점프
add $s0, $s1, $s2      # f = g + h
j Exit                 # if 분기 이후 exit으로 점프
Else: sub $s0, $s1, $s2 # f = g - h
Exit: ...              # 이후
```

만약 `j Exit` 가 없다면 `i` 와 `j` 가 같지 않더라도 내려오다 보면 Else로 가기 때문에, 같다면 바로 Exit으로 이동하도록 한다!

![](../images/Pasted%20image%2020250326144755.png)


---
# Compiling Loop Statements

```c
while (save[i]==k) i += 1;
i in $s3, k in $s5, address of save in $s6
```

```assembly
Loop:
	sll $t1, $s3, 2        # $t1 = i * 4 (워드 단위 주소 계산)
	add $t1, $t1, $s6      # $t1 = save + i*4 → save[i]의 실제 주소
	lw  $t0, 0($t1)        # $t0 = save[i]
	bne $t0, $s5, Exit     # if (save[i] != k) -> Exit
	addi $s3, $s3, 1       # i = i + 1
	j Loop                 # 반복
Exit: ...
```

### `sll $t1, $s3, 2  ` 
`$s3`의 값을 2비트 왼쪽으로 시프트 한다는건 2^2 = 4배를 해준다는 의미이다.

#### 왜 2비트를 시프트 했는데 4배가 될까?

2진수의 구조를 보면서 설명하면, 예를 들어 2진수 `00000101`은 **10진수로 5**다.

```
00000101  → 2³ × 0 + 2² × 1 + 2¹ × 0 + 2⁰ × 1 = 4 + 1 = 5
```

왼쪽으로 1비트 시프하면 아래와 같다.

```
00000101  → 00001010 → 2³ × 1 + 2² × 0 + 2¹ × 1 + 2⁰ × 0 = 8 + 2 = 10
```

두 개를 비교해보면 비트를 1 왼쪽으로 시프트 하면 모든 자리의 2의 지수가 1씩 커진다. 즉 전체 숫자의 2배가 된다!! **왼쪽으로 n번 시프트하면 전체 숫자는 2ⁿ배가 된다.**

다시 돌아가서 
`sll $t1, $s3, 2` 는 `$s3`의 값(`i`)을 2비트 왼쪽으로 시프트해서, 
`i × 4`의 값을 `$t1`에 저장하는 명령어이다.

이유는 save 배열이 `int`형이기 때문에, 
각 인덱스가 차지하는 크기가 4바이트(1워드)이기 때문이다.

즉, 배열의 시작 주소에 i × 4 만큼 더해주면 
save[i]의 정확한 메모리 주소에 접근할 수 있다.


#### `add $t1, $t1, $s6`

`$s6`에 있는 것은 save 배열의 시작 주소이기 때문에 `$t1` 의 값을 시작 주소에 더해줘 진짜 배열의 인덱스에 접근한거지

#### `lw  $t0, 0($t1)`
 
근데 `$t1`에 있는건 그냥 save 배열의 주소이기 때문에, `lw` 를 사용해서 `$t1` 의 데이터를 `$t0` 로 불러와야 한다. 이거 보면 레지스터에는 데이터가 담겨도 되고, 주소도 담겨도 되는거 같음! 주소도 데이터라 할 수 있으니깐

#### `bne $t0, $s5, Exit` 

이제 $t0 에 담긴 값과 $s5에 담긴 값을 비교해서 다르면 Exit으로 가고, 같다면 아래로 내려간다.

#### `addi $s3, $s3, 1`

`$s3` 에 1을 더해준다! `$s3`가 나타내는 것은 `i`이기 때문에 1을 더해줘서 다음 index로 가려는거지

#### 근데 `add`와 `addi`의 차이점은 뭘까?

> `add`는 **레지스터 + 레지스터**,  
> `addi`는 **레지스터 + 상수(immediate)**

지금은 이렇게만 알아두면 될 듯 하다!


---
# Basic Blocks

- **Basic block**은 **연속된 명령어들의 묶음**으로, **중간에 분기(branch)** 가 없고 (※ 끝에는 있을 수 있음) **외부에서 진입하는 분기 타겟**도 없음 (※ 시작점은 예외)

- **분기 없는 직선 코드 흐름**
- **시작~끝까지 순차적으로 실행됨**

- **컴파일러 최적화 단위**로 사용됨
- 고급 프로세서는 **basic block 단위로 실행 속도 향상 가능**

![](../images/Pasted%20image%2020250326160151.png)



---

# More Conditional Operations

상태가 `true`면 결과 값은 1이고, `false`면 0이다.

```assembly
slt rd, rs, rt
```

rs < rt 일 때, rd에 1을 할당, 그렇지 않다면 0을 할당

```assembly
slti rt, rs, constant
```

rs < constant 일 때, rt에 1을 할당, 그렇지 않다면 0을 할당

#### `beq`, `bne`의 조합으로 사용할 수 있다.

```assembly
slt $t0, $s1, $s2 # if ($s1 < $s2)
bne $t0, $zero, L # branch to L
```

---
# Branch Instruction Design

#### ❓ 왜 MIPS에는 `blt`, `bge` 같은 명령어가 없을까?

- `<`, `≥` 같은 비교 연산은 **`=`나 `≠`보다 하드웨어 구현이 느림**
- 이런 복잡한 비교를 분기(branch)와 **한 명령어에 합치면**,  명령어 하나 처리하는 데 **더 많은 회로와 시간**이 필요함
- 결국 **모든 명령어의 클럭 속도까지 느려짐** (전반적인 성능 저하)

#### ✅ 그래서 어떻게 했나?

- **`beq`, `bne` 같은 단순 비교만 하드웨어에 포함**
- `<`, `>`, `<=`, `>=` 같은 복잡한 비교는  → **별도의 `slt` 같은 명령어로 분리해서 처리**

---
# Signed vs Unsigned

Signed comparison : `slt`, `slti`
Unsigned comparison : `sltu`, `sltui`

![](../images/Pasted%20image%2020250326161918.png)


**같은 비트 값이라도 signed/unsigned 해석에 따라 완전히 다르게 비교된다.**  
비트 자체는 그냥 저장된 **0과 1의 나열**일 뿐이고,  
그것을 **어떻게 해석할지는 명령어(slt vs sltu)나 프로그래머의 관점**에 따라 달라진다.


---
## Proceduer Calling


1. **파라미터를 레지스터에 저장**  
    → 함수에 전달할 인자(argument)를 지정된 레지스터에 넣는다
    
2. **함수로 제어를 이동**  
    → `jal` 같은 명령어로 함수 호출
    
3. **함수를 위한 스토리지 확보**  
    → 스택 프레임(stack frame) 등으로 지역 변수 공간 확보
    
4. **함수 본연의 작업 수행**  
    → 함수 내부 로직 실행
    
5. **결과 값을 레지스터에 저장**  
    → 반환값을 호출자(caller)를 위한 레지스터에 넣음 (보통 `$v0`)
    
6. **호출 위치로 복귀**  
    → `jr $ra` 명령어로 복귀 주소(`$ra`)로 점프

---
## Register Usage

|레지스터|용도|번호|비고|
|---|---|---|---|
|`$a0`–`$a3`|인자(Arguments)|`$4`–`$7`|함수에 전달할 파라미터|
|`$v0`, `$v1`|반환값(Result values)|`$2`, `$3`|함수 결과|
|`$t0`–`$t9`|임시값(Temporaries)|`$8`–`$15`, `$24`, `$25`|**callee가 덮어써도 됨**|
|`$s0`–`$s7`|저장용(Saved)|`$16`–`$23`|**callee가 저장/복구해야 함**|
|`$gp`|전역 포인터(Global Pointer)|`$28`|static 데이터 접근용|
|`$sp`|스택 포인터(Stack Pointer)|`$29`|스택 최상단 위치|
|`$fp`|프레임 포인터(Frame Pointer)|`$30`|함수의 스택 프레임 기준점|
|`$ra`|리턴 주소(Return Address)|`$31`|호출한 함수로 돌아갈 주소 저장|

---

## Procedure Call Instructons

#### `jal ProcedureLabel` _(J-format)

- 현재 명령어 다음 주소 (`PC + 4`)를 `$ra`에 저장
- 지정된 함수 주소로 점프
    

#### `jr $ra` _(R-format)_
    
- `$ra`에 저장된 주소를 복사하여 program counter에 복사 점프 → 호출한 곳으로 복귀
- 컴퓨티드 점프(computed jump)에도 사용 가능  (예: `switch-case` 구문 구현)

---
## Leaf Procedure Example

```C++
int leaf_example ( int g, h, i, j)
{
	int f;
	f = ( g + h ) - ( i + j );
	return f;
}
```

| 변수       | 레지스터  |
| -------- | ----- |
| `g`      | `$a0` |
| `h`      | `$a1` |
| `i`      | `$a2` |
| `j`      | `$a3` |
| `f`      | `$s0` |
| `return` | `$v0` |

![](../images/Pasted%20image%2020250330181714.png)

```assemby
addi $sp, $sp, -4
```

`$sp` 는 스택 포인터인데 스택의 가장 아래를 가리킨다.  addi 를 통해 스택 포인터의 위치를 -4 하여 stack에 새로운 공간(4바이트)을 할당한다.

```assembly
sw $s0, 0($sp)
```

`$s0` 의 값, 즉 f를 `$sp` 에 저장한다.  왜 저장하냐면 $s0의 값은 함수 밖에서 사용되고 있었을 수도 있기 때문에 함수가 끝날 경우 복구시켜줘야 한다. 그래서 stack 에 따로 저장해두는 것!

```assembly
add $t0, $a0, $a1
add $t1, $a2, $a3
sub $s0, $t0, $t1
```

함수의 변수를 더하고 임시 변수에 저장하고, 임시 변수들끼리 빼서 스택에 저장한 $s0에 저장한다.

```assembly
add $v0, $s0, $zero
```

저장된 $s0의 값을 결과 값으로 옮긴다.

```assembly
lw $s0, 0($sp)
addi $sp, $sp, 4
```

$sp 의 값을 $s0에 불러온다. 즉 함수가 끝날 때 원래 $s0값을 복구해주는 것이다. 

```assembly
jr $ra
```

**복귀 주소($ra)** 로 점프하여  호출한 함수로 돌아감
`jal`로 함수가 호출됐기 때문에, `$ra`에 복귀 주소가 저장되어 있다.

---
## Non-Leaf Procedures

Non-Leaf Procedures는 다른 함수를 호출하는 함수를 말한다.

중첩 호출이 있는 경우, **caller는 스택에 다음 정보를 저장**해야 함:
    - **return address**
    - 다음 호출에서 필요한 **변수**나 **임시 레지스터 값**
        
함수 호출이 끝난 후에는,  **저장해둔 값들을 스택에서 복구**해야 함


---
## **Non - Leaf Procedure Example**

```C++
int fact (int n)
{ 
	if (n < 1) return 1;
	else return n * fact(n - 1);
}
```

| 변수     | 레지스터  |
| ------ | ----- |
| n      | `$s0` |
| result | `$v0` |


![](../images/Pasted%20image%2020250330183432.png)

- `$ra` RET (org return address)
- `$a0` N (org n)


```assembly
addi $sp, $sp, -8 # adjust stack for 2 items
sw $ra, 4($sp) # save return address
sw $a0, 0($sp) # save argument
```

- `addi $sp, $sp, -8`: 스택에 8바이트 공간 확보 (int 2개 크기)
- `4($sp)`: 스택 포인터 기준 4바이트 위 → `$ra` 저장
- `0($sp)`: 스택 포인터가 가리키는 곳 → `$a0` 저장

```assembly
slti $t0, $a0, 1 # test for n < 1
beq $t0, $zero, L1
```

- `$a0`가 **1보다 작으면** → `$t0 = 1` → `beq` 안 됨 → 아래로 진행 (base case 처리)
- `$a0`가 **1 이상이면** → `$t0 = 0` → `beq $t0, $zero, L1` → **L1로 분기 (재귀 호출)**

```assembly
addi $v0, $zero, 1 # if so, result is 1
addi $sp, $sp, 8 # pop 2 items from stack
jr $ra # and return
```

- `addi $v0, $zero, 1`   반환값 1을 `$v0`에 저장 (base case: `if (n < 1) return 1;`)
- 앞서 저장했던 `$ra`, `$a0`를 스택에서 **복구하지 않고 버리고** → **스택 공간만 해제**
	base case에서는 **값을 다시 사용할 일이 없기 때문에**  **스택 포인터만 원래대로 되돌리고**, 그냥 복귀하면 됨, 재귀가 끝났기 때문에 임시 값들을 복구 안 해도 되는거지!
	
- `jr $ra`  를 통해 함수 호출 전으로 복귀

```assembly
addi $a0, $a0, -1 # else decrement n 
jal fact # recursive call
```

$a0의 값, 즉 n을 -1을 해주고 fact 함수를 다시 실행해준다.

---
##### L1 (재귀 호출 이후 복귀 지점)

```assembly
lw $a0, 0($sp) # restore original n
lw $ra, 4($sp) # and return address
addi $sp, $sp, 8 # pop 2 items from stack
```

- `$a0`에 저장된 원래 n 값 불러오기
- `$ra`에 리턴 주소 복원
- 증가시켜서 스택 포인터 원래 상태로 복구

```assembly
mul $v0, $a0, $v0 # multiply to get result
jr $ra # and return
```

- 현재 n과 재귀에서 돌아온 결과를 곱함
- 최종 결과를 `$v0`에 저장 후 복귀

----
## Local Data on the Stack

![](../images/Pasted%20image%2020250330185147.png)

- **지역 변수(local data)** 는 **callee(호출된 함수)** 가 스택에 공간을 할당해 사용
- 이러한 공간은 **프로시저 프레임(Procedure Frame)**  또는 **활성화 레코드(Activation Record)** 라고 불림
- **컴파일러**는 이 구조를 사용해  **함수마다 필요한 스택 공간을 정리하고 관리**함

---
## Memory Layout

![](../images/Pasted%20image%2020250330185413.png)

#### ✅ **Text**

- **프로그램 코드**가 저장되는 영역
- 컴파일된 명령어(instructions)들이 이곳에 위치함
    
#### ✅ **Static Data**

- **전역 변수**, **정적 변수**, **상수 배열**, **문자열 상수** 등이 저장됨
- C에서 `static`, `const`로 선언된 데이터가 해당
- `$gp`(global pointer)는 이 영역을 기준으로 offset 접근이 가능하도록 초기화됨

#### ✅ **Dynamic Data (Heap)**

- 런타임 중에 동적으로 할당되는 메모리 영역
- 예: `malloc`, `new` 같은 동적 메모리 할당
- 프로그램 실행 중 크기가 늘어나거나 줄어들 수 있음

#### ✅ **Stack**

- **자동 저장소 (automatic storage)**
- 함수 호출 시 지역 변수, 리턴 주소, 레지스터 저장 등이 이곳에서 처리됨
- 함수 호출 시 아래로(stack 감소), 함수 종료 시 위로(stack 증가)

---
## **Character Data**

#### ✅ ASCII

- **총 128개 문자**
- 95개는 **출력 가능한 문자(graphic)**
- 33개는 **제어 문자(control)**

#### ✅ Latin-1 (ISO 8859-1)

- **총 256개 문자**
- ASCII 포함 + **96개 추가 graphic 문자**

#### ✅ Unicode

- **32비트 문자 집합** (이론상 2³²개 표현 가능)
- 대부분의 **세계 문자 체계 + 기호** 포함
- 사용 예: Java, C++의 wide character (`wchar_t`)

#### ✅ UTF-8 / UTF-16

- **Unicode의 가변 길이 인코딩 방식**
- UTF-8: 1~4바이트
- UTF-16: 2 또는 4바이트

---
## Byte/Halfword Operations

- **비트 연산(bitwise operations)** 을 이용해 **문자열 처리 등**에 유용하게 사용됨
- MIPS는 **바이트(byte), 하프워드(halfword)** 단위의 로드/스토어를 지원함
좋아! 주신 내용을 기준으로 **MIPS의 바이트/하프워드 메모리 접근**과 관련된 내용을 깔끔하게 정리해줄게:

| 명령어                  | 설명                                 |
| -------------------- | ---------------------------------- |
| `lb rt, offset(rs)`  | **1바이트 로드** + 부호 확장 (sign-extend)  |
| `lh rt, offset(rs)`  | **2바이트(하프워드) 로드** + 부호 확장          |
| `lbu rt, offset(rs)` | **1바이트 로드** + 0으로 확장 (zero-extend) |
| `lhu rt, offset(rs)` | **2바이트 로드** + 0으로 확장               |

- **sign-extend**: 최상위 비트를 32비트까지 복제 (음수 보존)
- **zero-extend**: 상위 비트를 전부 0으로 채움
    
|명령어|설명|
|---|---|
|`sb rt, offset(rs)`|레지스터의 **하위 1바이트만 저장**|
|`sh rt, offset(rs)`|레지스터의 **하위 2바이트(하프워드) 저장**|

- 상위 바이트는 무시됨
- 전체 워드가 아닌 **부분 저장**에 사용됨
    

---
## String Copy Example

```C++
void strcpy (char x[], char y[])
{ 
	int i;
	i = 0;
	while ((x[i]=y[i])!='\0')
		i += 1;
}
```

• Addresses of x, y in $a0, $a1
• i in $s0

![](../images/Pasted%20image%2020250330222458.png)

```assembly
addi $sp, $sp, -4 # adjust stack for 1 item
sw $s0, 0($sp) # save $s0
add $s0, $zero, $zero # i = 0
```

$sp의 공간 확보하고  $sp에 $s0의 값을 저장한다. 그리고 $s0는 0을 넣어준다.  

L1: 
```assembly
add $t1, $s0, $a1 # addr of y[i] in $t1
lbu $t2, 0($t1) # $t2 = y[i]
```

$a1에는 x배열의 시작 주소가 담겨 있다 . $s0 즉