---

---

## **Integer Addition**

Example 7 + 6
![](../images/Pasted%20image%2020250401154607.png)

결과 값이 표현 범위를 넘어서면 **오버플로우(overflow)** 가 발생한다.  
`+ve`(양수)와 `-ve`(음수)를 더하는 연산에서는 오버플로우가 발생하지 않는다.

하지만 두 개의 `+ve`(양수)를 더했을 때 오버플로우가 발생하면, **결과의 부호 비트가 1**로 바뀌어 음수처럼 보이게 된다.  
반대로 두 개의 `-ve`(음수)를 더했을 때 오버플로우가 발생하면, **결과의 부호 비트가 0**이 되어 양수처럼 보인다.


---
## **Integer Subtraction**

Example 7 - 6 = 7 + (-6)
![](../images/Pasted%20image%2020250401235049.png)

|연산 유형|오버플로우 발생 여부|오버플로우 발생 조건|
|---|---|---|
|+ve - +ve 또는 -ve - -ve|❌ 없음|없음|
|-ve - +ve|✅ 가능성 있음|결과의 부호가 **0(양수)**일 때|
|+ve - -ve|✅ 가능성 있음|결과의 부호가 **1(음수)**일 때|


---
## **Dealing with Overflow**

C와 같은 일부 언어는 **오버플로우를 무시**한다.  
MIPS에서도 `addu`, `addiu`, `subu` 같은 명령어는 **오버플로우를 검사하지 않는다.**

반면, **Ada**나 **Fortran**과 같은 언어는 오버플로우가 발생하면 **예외를 발생시킨다.**  
MIPS에서는 `add`, `addi`, `sub` 명령어가 이에 해당하며,  오버플로우 발생 시 **예외 핸들러가 호출된다.**

이때, 현재 명령어의 주소는 **EPC(Exception Program Counter)** 레지스터에 저장되며,  
제어 흐름은 사전에 정의된 **예외 핸들러 주소**로 이동한다.  
예외 처리 후에는 `mfc0`(move from coprocessor 0) 명령어를 사용해  
EPC 값을 복원하고, 적절한 조치를 취한 뒤 **원래 실행하던 위치로 복귀**할 수 있다.

---
## **Arithmetic for Multimedia**

그래픽이나 8비트의 벡터나 16비트 데이터에서 동작하도록 설정된 미디아는 64-bit adder를 사용한다. with partitioned car