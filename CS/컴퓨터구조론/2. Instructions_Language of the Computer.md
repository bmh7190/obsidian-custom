---

---

---
### 🏛️ Instruction Set

**Instruction Set**은 컴퓨터가 수행할 수 있는 기능들의 집합이다.  
각 컴퓨터마다 고유한 **Instruction Set**을 가지지만, 기본적인 동작 원리는 유사하다.  
초기 컴퓨터들은 매우 단순한 Instruction Set을 가지고 있었으며,  
오늘날의 많은 현대 컴퓨터들도 여전히 간결한 Instruction Set을 유지하고 있다.

---

### 🔢 Arithmetic Operations

**덧셈(Add)과 뺄셈(Subtract)** 연산은 **3개의 피연산자(Operands)**를 사용한다.

- **두 개(Source)**는 연산할 값이고,
- **하나(Destination)**는 결과를 저장할 레지스터이다.

assembly

복사편집

`add a, b, c  # a ← b + c sub a, b, c  # a ← b - c`

모든 산술 연산(Arithmetic Operations)은 이와 같은 형식을 따른다.

> **📌 Design Principle 1**: 단순한 연산일수록 규칙적인 형식을 따르는 것이 좋다.

---

### 📌 Register Operands

산술 연산(Arithmetic Instructions)은 **레지스터(Register)**를 사용하여 데이터를 처리한다.  
MIPS 프로세서는 **32개의 32비트 레지스터 파일(Register File)**을 제공하며,  
이는 **자주 사용되는 데이터**를 저장하는 용도로 활용된다.

- 레지스터는 **0번부터 31번까지 번호가 부여**되며,
- 32비트 데이터 단위를 **워드(Word)**라고 부른다.

💾 **어셈블러(Assembler)에서 사용하는 레지스터 명칭**

- `$t0, $t1, ... , $t9` → **임시 값(Temporary Values) 저장**
- `$s0, $s1, ... , $s7` → **저장된 변수(Saved Variables) 저장**

> **📌 Design Principle 2**: **레지스터 크기가 작을수록 연산 속도는 더 빨라진다.**

---
### 🖥️ **Main Memory for Composite Data**

산술 연산(Arithmetic Operations)을 적용하기 위해, **메인 메모리(Main Memory)**를 사용하여 데이터를 불러오거나 저장할 수 있다.

#### **📌 메모리에서 데이터 로드 및 저장**

```assembly
lw $t0, 8($s1)  # 메모리에서 값을 불러와 $t0에 저장 (Load Word) 
sw $t0, 8($s1)  # $t0의 값을 메모리에 저장 (Store Word)`
```

- `lw (Load Word)` : 메모리에서 데이터를 불러와 레지스터에 저장
- `sw (Store Word)` : 레지스터 값을 다시 메모리에 저장

---

### 📌 **메모리 주소와 데이터 정렬**

✅ **MIPS의 메모리 특성**

- **메모리는 바이트(Byte) 단위로 주소가 할당됨**
- **각 주소(Address)는 8비트(1바이트) 데이터를 가리킴**
- **워드(Word)는 메모리에 정렬(Aligned)되어 저장됨**
- **주소는 항상 4의 배수(Multiple of 4)여야 함**

✅ **MIPS는 Big Endian 방식을 사용**

- 워드(Word) 내에서 **가장 큰 값(Most Significant Byte, MSB)**이 **가장 작은 주소(Least Address)**에 저장됨

📌 **정리하면:**

- 메모리는 **바이트 주소로 관리**되며,
- **4바이트 정렬**을 유지해야 하며,
- **MIPS는 빅 엔디언(Big Endian) 방식**을 따른다.

---
### Littele vs Big endian

Example
- vaiable x has 4-byte value of 0x01234567
- Address given by &x is 0x100

![[Pasted image 20250319102729.png]]

- **Big Endian**: 주소가 작은 곳부터 **가장 큰 값**이 저장되고, 점점 작은 값이 뒤에 배치된다.
- **Little Endian**: 주소가 작은 곳부터 **가장 작은 값**이 저장되고, 점점 큰 값이 뒤에 배치된다.


---

### Memory Operand Example 1

#### C Code

```c
g = h + A[8];
```

- `g` → `$s1`
- `h` → `$s2`
- `A` 배열의 **베이스 주소** → `$s3`

#### Compiled MIPS Code

```assembly

# 배열 A의 인덱스 8은 오프셋 32를 필요로 함 
# (4바이트 * 8 = 32) 
lw $t0, 32($s3)   # A[8]의 값을 로드하여 $t0에 저장 
add $s1, $s2, $t0 # g = h + A[8]

```

- 배열은 **4바이트(Word) 단위**로 저장되므로,  
- 인덱스 8에 해당하는 메모리 오프셋은 `8 × 4 = 32` 바이트가 됨.
- `lw` 명령어를 사용해 `A[8]`의 값을 `$t0`에 로드한 후,
- `add` 명령어로 `h`와 `A[8]`을 더해 `g`에 저장.

---
### Memory Operand Example2

#### C Code

```c
A[12] = h + A[8]
```

- `h` → `$s2`
- `A` 배열의 **베이스 주소** → `$s3`

#### Compiled MIPS Code

```assembly

# 배열 A의 인덱스 8은 오프셋 32를 필요로 함 
# (4바이트 * 8 = 32) 

lw $t0, 32($s3)   # A[8]의 값을 로드하여 $t0에 저장 
add $$t0, $s2, $t0
sw $t0, 48($s3)

```

- 배열은 **4바이트(Word) 단위**로 저장되므로,  
- 인덱스 8에 해당하는 메모리 오프셋은 `8 × 4 = 32` 바이트가 됨.
- `lw` 명령어를 사용해 `A[8]`의 값을 `$t0`에 로드한 후,
- `add` 명령어로 `h`와 `A[8]`을 더해 `$t0`에 저장.
- 인덱스 12에 해당하는 메모리 오프셋은 `12 × 4 = 48` 바이트가 됨.
- `sw` 명령어를 사용해 `A[12]`에 `$t0`를 저장.


---
### Registers vs. Memory

- **레지스터(Register)**는 **메모리보다 더 빠르게** 접근할 수 있음.
- 메모리에서 데이터를 가져오거나 저장하는 작업은 **`load`와 `store` 명령어**가 필요하며, 이는 **더 많은 명령어 실행**을 요구함.

#### **컴파일러의 역할**

컴파일러는 가능한 한 **많은 변수**를 **레지스터**에 할당해야 함.

- **자주 사용되지 않는 변수**만 메모리에 저장 (spill)
- **레지스터 최적화**가 성능에 중요한 영향을 미침

---
### Immediate Operands

- 상수(Constant) 데이터를 **명령어 내부에서 직접 지정**할 수 있음.
    ```assembly
    addi $s3, $s3, 4  # $s3에 4를 더함
    ```
    

#### Subtraction with Immediate Values

MIPS에는 **subtract immediate(`subi`) 명령어가 없음**.  
대신 **음수 상수(negative constant)**를 사용하여 뺄셈을 수행함.

```assembly
addi $s2, $s1, -1  # $s2 = $s1 - 1
```

 
> **📌 Design Principle 3: ** 보통의 경우에 더 빠르게 하라
- 작은 상수(Small Constants)는 **자주 사용됨**.
- **Immediate Operand**를 사용하면 **추가적인 load 명령어 없이** 빠르게 연산 가능.

---
### The Constant Zero

- MIPS의 **레지스터 0(`$zero`)**는 항상 **상수 0**을 저장하고 있음.
- 값을 변경할 수 없음 (**cannot be overwritten**).
- 일반적인 연산에서 유용하게 활용됨.

---
### Unsigned Binary Integers

**n비트의 부호 없는 이진 정수(Unsigned Binary Integer)**는 다음과 같은 식으로 표현됨:

$$x=xn−1⋅2n−1+xn−2⋅2n−2+⋯+x1⋅21+x0⋅20x = x_{n-1} \cdot 2^{n-1} + x_{n-2} \cdot 2^{n-2} + \dots + x_1 \cdot 2^1 + x_0 \cdot 2^0$$

모든 비트가 **크기를 나타내는 값**으로 사용되며, **부호 비트(Sign Bit)가 없음**.

---

### **범위 계산**

$$0≤x≤2n−10 \leq x \leq 2^n - 1$$

- 4비트: `0` ~ `15`
- 8비트: `0` ~ `255`
- 16비트: `0` ~ `65,535`
- 32비트: `0` ~ `4,294,967,295`

---
### Signed Binary Integers

부호 있는 정수(Signed Integer)는 **이진수 표현**에서 가장 높은 비트(MSB, Most Significant Bit)를 **부호 비트(Sign Bit)**로 사용하여 음수를 표현할 수 있음.

#### **2의 보수(Two’s Complement) 표현**

n비트의 정수 `x`는 다음과 같이 나타냄:

$$x=−xn−1⋅2n−1+xn−2⋅2n−2+⋯+x1⋅21+x0⋅20x = -x_{n-1} \cdot 2^{n-1} + x_{n-2} \cdot 2^{n-2} + \dots + x_1 \cdot 2^1 + x_0 \cdot 2^0$$


- `x_{n-1}`: **부호 비트(Sign Bit)**
    - `0`: 양수
    - `1`: 음수
- 나머지 비트는 **크기를 나타내는 값**

#### **예제: 4비트 Signed Integer**

| 2진수    | 10진수 해석                                                                                  | 값    |
| ------ | ---------------------------------------------------------------------------------------- | ---- |
| `0111` | $$ 0×(−23)+1×22+1×21+1×200 \times (-2^3) + 1 \times 2^2 + 1 \times 2^1 + 1 \times 2^0 $$ | `+7` |
| `0001` | $$0×(−23)+0×22+0×21+1×200 \times (-2^3) + 0 \times 2^2 + 0 \times 2^1 + 1 \times 2^0$$   | `+1` |
| `0000` | $$0×(−23)+0×22+0×21+0×200 \times (-2^3) + 0 \times 2^2 + 0 \times 2^1 + 0 \times 2^0$$   | `0`  |
| `1111` | $$1×(−23)+1×22+1×21+1×201 \times (-2^3) + 1 \times 2^2 + 1 \times 2^1 + 1 \times 2^0$$   | `-1` |
| `1000` | $$1×(−23)+0×22+0×21+0×201 \times (-2^3) + 0 \times 2^2 + 0 \times 2^1 + 0 \times 2^0$$   | `-8` |

#### Specific numbers
- 0 : 0000 0000 ... 0000
- -1 : 1111 1111 ... 1111
- Most-negative : 1000 0000 ... 0000
- Most-positive : 0111 1111 ... 1111

---
### Signed Negation

#### 2의 보수(Two’s Complement) 방식으로 음수 표현

1. **1의 보수(Complement)**: 모든 비트를 반전 (1 → 0, 0 → 1)
2. **1을 더하기(Add 1)**

#### **수식**

x+x‾=1111...11112=−1x + \overline{x} = 1111...1111_2 = -1 x‾+1=−x\overline{x} + 1 = -x

#### **예제: +2를 음수로 변환**

1. **+2의 2진 표현:**
    
    ```
    0000 0000 ... 0010₂
    ```
    
2. **1의 보수 적용:**
    
    ```
    1111 1111 ... 1101₂
    ```
    
3. **1을 더함:**
    
    ```
    1111 1111 ... 1110₂
    ```
    
    → `-2`의 2의 보수 표현

---
### Sign Extension

#### **정수를 더 많은 비트로 표현**

- 숫자의 값을 유지하면서 비트 수를 늘리는 방법
- **부호(Sign Bit)를 유지해야 함**

#### **MIPS 명령어에서 사용되는 경우**

- `addi`: 즉시 값(Immediate Value) 확장
- `lb`, `lh`: 바이트(Byte) 또는 하프워드(Halfword) 로드 시 확장
- `beq`, `bne`: 분기(Branch) 시 변위(Displacement) 확장

#### **부호 확장의 원칙**

- **부호 비트를 왼쪽으로 복제**
- **부호 없는 값(Unsigned Value)**의 경우 **0을 추가**

#### **예제: 8비트를 16비트로 확장**

1. **양수 (+2)의 확장**
    
    ```
    0000 0010  →  0000 0000 0000 0010
    ```
    
2. **음수 (-2)의 확장**
    
    ```
    1111 1110  →  1111 1111 1111 1110
    ```
    

부호 확장을 통해 **음수는 그대로 음수로 유지되고, 양수는 값이 보존됨**.

---
# Representing Instructions

- 명령어는 **이진수(binary)** 로 인코딩된다.
- 이를 **머신 코드(machine code)** 라고 부른다.
- MIPS 명령어는 **32비트 길이의 명령어 워드(word)** 로 인코딩된다.
- 소수의 형식을 사용하여 연산 코드(opcode), 레지스터 번호 등을 표현한다.
- 포맷이 규칙적이어서 해석하기 쉽다.

### 🗂️ 레지스터 번호

| 이름          | 번호 범위 |
| ------------- | --------- |
| `$t0` ~ `$t7` | 8 ~ 15    |
| `$t8` ~ `$t9` | 24 ~ 25   |
| `$s0` ~ `$s7` | 16 ~ 23   |

---
# MIPS R-format instructions

![[Pasted image 20250326132437.png]]

## Instuction fields

- **op** : 연산 코드 (operation code)
- **rs** : 첫 번째 소스 레지스터 번호 (first source register number)
- **rt** : 두 번째 소스 레지스터 번호 (second source register number)
- **rd** : 결과를 저장할 목적지 레지스터 번호 (destination register number)
- **shamt** : 쉬프트 양 (shift amount) → 현재는 `00000` 고정
- **funct** : 함수 코드 (function code) → opcode를 보완하여 연산을 구체화함

`opcode` 와 `funct` 를 함께 사용하여 어떤 명령어인지 구체적으로 표현한다.
레지스터는 총 **32개** 존재하며, 각각을 **5비트**로 표현한다.

## R-format Example

```assembly
add $t0, $s1, $s2
```

![[Pasted image 20250326132948.png]]

`$s1` 레지스터와 `$s2` 레지스터의 값을 더해서 **$t0**에 저장하라는 의미

```
00000010001100100100000000100000
```

어셈블리어에서는 명령어를 `rd, rs, rt` 순서로 작성한다. 하지만 R-format으로 인코딩될 때는 레지스터가 `rs, rt, rd` 순서로 배치된다. 

---

# MIPS I-format Instructions

![[Pasted image 20250326133525.png]]

## Imediate arithmetic and load/store instructions

- `rs`: 연산에 사용되는 **소스 레지스터**
- `rt`: 상황에 따라 **소스 또는 목적지 레지스터**로 사용됨
- `constant`: 16비트 상수값, 범위는 **-2¹⁵ ~ 2¹⁵ - 1**
- `address`: 메모리 접근 시 사용하는 **주소 오프셋(offset)**

![[Pasted image 20250326133823.png]]


#### ✅ `lw` (load word)

- **형태**: `lw rt, offset(rs)`
- **기능**: `rs`가 가리키는 메모리 주소에서 `offset`만큼 떨어진 곳에 있는 **값을 읽어**와서 `rt`에 저장
- **역할**: 메모리 → 레지스터
    
```assembly
lw $t0, 4($s1)
```
→ `$s1 + 4` 주소에 있는 값을 `$t0`에 로드

#### ✅ `sw` (store word)

- **형태**: `sw rt, offset(rs)`
- **기능**: `rt`에 있는 **값을 메모리에 저장**  / 주소는 `rs + offset`으로 계산
- **역할**: 레지스터 → 메모리

```assembly
sw $t0, 4($s1)
```

→ `$t0`의 값을 `$s1 + 4` 주소에 저장


#### ✅ `addi` (add immediate)

- **형태**: `addi rt, rs, immediate`
- **기능**: `rs`의 값과 `immediate` 값을 더해서 결과를 `rt`에 저장
- **역할**: 간단한 정수 덧셈

```assembly
addi $t0, $s1, 10
```

→ `$s1 + 10` 결과를 `$t0`에 저장



필요하면 이 명령어들의 이진 인코딩이나 예시 하나 골라서 분석도 가능해! 더 이어서 정리할까?