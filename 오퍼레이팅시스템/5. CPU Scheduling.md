---

---
# CPU Scheduler

✅ 프로세스 상태 변화와 큐 간 이동

운영체제는 **다양한 큐(예: Ready Queue, I/O Queue 등)** 를 유지하면서  **프로세스의 상태 변화에 따라 해당 큐 간에 프로세스를 이동시킨다.**

![](../images/Pasted%20image%2020250328172852.png)

✅ 단기 스케줄러 (Short-Term Scheduler or CPU Scheduler)
**Ready Queue** 에 있는 프로세스들 중에서  **어떤 프로세스를 CPU에 할당할지 선택하는 역할**을 한다.

**CPU 스케줄러는 가장 자주 호출되는 스케줄러**이며,  → **밀리초 단위로 매우 자주 실행되므로 빠르게 동작해야 한다.**

일부 시스템에서는 **short-term scheduler가 유일한 스케줄러**일 수 있다.

---
# Basic Concept of CPU scheduling

**CPU를 최대한 활용**하려면, **시간 공유(Time-sharing)** 시스템에서는  **CPU에 할당된 프로세스를 빠르게 전환(Switch)해주는 것**이 중요하다.

### CPU burst 와 I/O burst

대부분의 프로세스 실행은 다음 두 가지 주기로 구성된다:

    1. **CPU Burst**: CPU를 사용하여 계산 수행
    2. **I/O Burst**: I/O 작업을 기다리는 시간 (예: 디스크, 네트워크 등)
        
        
일반적인 실행 흐름은 다음과 같다:  → **CPU Burst → I/O Burst → CPU Burst → ...**
    
따라서 CPU 스케줄링에서 중요한 점은 **CPU Burst의 분포(distribution)** 를 잘 파악하고  그에 맞게 **효율적인 스케줄링 정책**을 적용하는 것이다.

---
# CPU Scheduler

**CPU 스케줄러**는 **메모리 상에서 실행 준비(ready) 상태에 있는 프로세스들 중 하나를 선택**하여  **CPU를 할당**한다.

CPU 스케줄러는 **다음과 같은 경우에 스케줄링 결정을 내린다:**

1. 프로세스가 **Running → Waiting 상태**로 전환될 때  (예: I/O 요청 등)
2. 프로세스가 **Running → Ready 상태**로 전환될 때  (예: 타이머에 의한 시간 할당 종료 등)
3. 프로세스가 **Waiting → Ready 상태**로 전환될 때  (예: I/O 작업 완료 등)
4. 프로세스가 **종료(Terminated)** 될 때


- **1번과 4번**은 **Non-preemptive(비선점)** 상황  → 현재 프로세스가 **자연스럽게 CPU를 반납**
- **2번과 3번**은 **Preemptive(선점)** 상황  → CPU를 **강제로 다른 프로세스로 전환**할 수 있음


---

CPU 스케줄러는 **시스템 설계 원칙 중 하나인 정책과 메커니즘의 분리(Separation of Policy and Mechanism)** 에 따라 설계된다.

- **스케줄링 정책 (Scheduling Policy)**
    - 어떤 프로세스를 선택할지 결정하는 **전략(what to do)**
    - 예: FCFS, SJF, Round Robin, Priority 등
        
- **디스패처 (Dispatcher)**
    - 선택된 프로세스를 **실제로 CPU에 할당**하는 **동작(how to do)**
    - 컨텍스트 스위칭, 사용자 모드 전환, 프로그램 카운터 복원 등의 기능 포함

![](../images/Pasted%20image%2020250329234422.png)

---
# Dispatcher

**Dispatcher 모듈**은 **CPU 스케줄러가 선택한 프로세스에게 CPU 제어권을 넘겨주는 역할**을 한다.  
이 과정에는 다음 작업이 포함된다:

- **컨텍스트 스위칭**
- **사용자 모드로 전환**
- **사용자 프로그램의 재시작 위치로 점프**

#### ✅ Dispatcher는 어떻게 제어를 유지할까?

- **CPU는 한 번에 하나의 작업만 수행 가능**하다.
- 즉, **사용자 프로세스가 실행 중일 때는 디스패처는 실행되지 않는다.**

#### ✅ Dispatcher는 어떻게 제어를 다시 얻는가?

#####  **Non-Preemptive 방식**

- 운영체제가 **프로세스를 신뢰**하고,  
    → 프로세스가 **자발적으로 CPU를 반환**하거나 시스템 콜, I/O 요청 등을 통해  
    → **디스패처에게 제어를 넘겨주기를 기대**함.
    
- 하지만 이 방식은 **프로세스가 오작동하거나 반환하지 않으면 시스템 전체가 멈출 수 있음**.  
    → **신뢰 기반, 위험 존재**
    
#####  **Preemptive 방식**

- **디스패처에게 알람 시계를 제공**하여 강제로 제어권을 회수함.
    
- **타이머 하드웨어와 인터럽트(Interrupt)** 를 사용하여  
    → 일정 시간마다 **타이머 인터럽트를 발생시켜 커널로 제어를 전환**  
    → 디스패처가 다시 실행되어 **스케줄링 결정 수행 가능**

#### ✅ 운영체제로의 제어 권한 반환 (Control Returns to OS)

운영체제는 **다양한 이벤트를 통해 제어를 다시 획득**한다.  
이 이벤트는 **내부적인 것(traps, faults)** 과 **외부적인 것(interrupts)** 으로 나뉜다.

#####  Traps & Faults (내부 이벤트 – User Process 내부에서 발생)

- **시스템 콜 (System Call)**  → 사용자 프로세스가 OS의 서비스를 요청할 때
- **부동 소수점 예외 (Floating Point Exception)**  → 0으로 나누기 등 잘못된 계산 발생 시
- **페이지 폴트 (Page Fault)**  → 접근하려는 메모리 페이지가 메모리에 없을 때

#####  Interrupts (외부 이벤트 – User Process 외부에서 발생)

- **키보드 입력**  → 사용자가 터미널에 문자를 입력한 경우
- **디스크 전송 완료**  → I/O 장치에서 작업이 끝났을 때 OS에 알림    
- **타이머 인터럽트**  
    → OS가 **시간을 강제로 회수**하기 위해 설정한 타이머가 만료되었을 때  
    → **프로세스가 CPU를 독점하지 않도록 보장**

---
#### ✅ 디스패처는 어떻게 상태를 저장하고 복구하는가?

→ **Context Switch 메커니즘**을 통해 이루어진다.

#### Context Switch란?

- 현재 실행 중인 **프로세스의 상태(컨텍스트)** 를 저장하고,  
    다음에 실행할 프로세스의 상태를 복원하는 과정이다.
- 이 과정은 **디스패처(dispatcher)** 가 수행하며,  
    → 다른 프로세스에게 CPU를 넘기기 위해 반드시 필요하다.


####  반드시 저장해야 하는 것들

> 다음 프로세스가 **손상시킬 수 있거나 영향을 줄 수 있는 모든 것**을 저장해야 한다.

- **Program Counter (PC)**
- **Processor Status Word (PSW)**: CPU 상태 및 제어 플래그
- **General Purpose Registers**: 범용 레지스터
- **Floating-Point Registers**: 부동소수점 연산용 레지스터 (필요한 경우)


####  메모리는 전부 저장해야 할까?

- **모든 메모리를 저장하는 것은 현실적으로 비용이 너무 큼**  
    → 메모리는 용량이 크기 때문에, **모든 내용을 저장/복구하는 것은 비효율적**
    
- 따라서 **필요할 경우에만 일부 메모리를 디스크로 스왑(swap)** 한다  
    → 예: 페이지 교체, 프로세스 일시 중단 등

---
